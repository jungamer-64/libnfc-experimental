// include/libnfc_rs.h

// This header is generated by cbindgen. Do not edit manually.
// Regenerate with: cbindgen --config rust/libnfc-rs/cbindgen.toml --crate libnfc-rs --output rust/libnfc-rs/include/libnfc_rs.h

// Manually-provided macros for values that cbindgen cannot emit
#define LOG_CATEGORY "libnfc.common"
#define MALLOC_LABEL "malloc"

#ifndef LIBNFC_RS_H
#define LIBNFC_RS_H

#pragma once

/* Generated with cbindgen:0.29.0 */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define NFC_COMMON_SUCCESS 0

#define NFC_COMMON_ERROR -1

#define LOG_GROUP_GENERAL 1

#define LOG_PRIORITY_ERROR 1

#define LOG_PRIORITY_DEBUG 3

#define NFC_BUFSIZE_CONNSTRING 1024

#define NFC_SECURE_SUCCESS 0

#define NFC_SECURE_ERROR_INVALID -1

#define NFC_SECURE_ERROR_OVERFLOW -2

#define NFC_SECURE_ERROR_RANGE -3

#define NFC_SECURE_ERROR_ZERO_SIZE -4

#define NFC_SECURE_ERROR_INTERNAL -5

#if !defined(RUST_TEST)
extern void log_put_message(uint8_t group,
                            const char *category,
                            uint8_t priority,
                            const char *message);
#endif

int nfc_parse_connstring(const char *connstring,
                         const char *prefix,
                         const char *param_name,
                         char *param_value,
                         size_t param_value_size);

int nfc_build_connstring(char *dest,
                         size_t dest_size,
                         const char *driver_name,
                         const char *param_name,
                         const char *param_value);

const char *nfc_get_last_error(void);

void nfc_clear_last_error(void);

void nfc_set_last_error(const char *message);

/**
 * Free memory allocated by Rust FFI helpers
 */
void nfc_rs_free(void *ptr);

int connstring_decode(const char *connstring,
                      const char *driver_name,
                      const char *bus_name,
                      char **pparam1,
                      char **pparam2);

/**
 * Copy `src_size` bytes from `src` to `dst` after validating the
 * provided buffer sizes and pointers.
 *
 * Returns one of the libnfc secure error codes:
 * - `NFC_SECURE_SUCCESS` (0) on success
 * - `NFC_SECURE_ERROR_INVALID` when `dst` or `src` is NULL
 * - `NFC_SECURE_ERROR_OVERFLOW` when `dst_size < src_size`
 * - `NFC_SECURE_ERROR_RANGE` when a supplied size is unreasonably large
 *
 * # Safety
 * Both `dst` and `src` must point to valid memory regions for
 * `src_size` bytes. The regions must not overlap; use
 * `nfc_safe_memmove` when overlapping copies are required.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_safe_memcpy;
 * let mut dst = [0u8; 16];
 * let src = [1u8, 2, 3, 4];
 * let rc = unsafe {
 *     nfc_safe_memcpy(
 *         dst.as_mut_ptr() as *mut _,
 *         dst.len(),
 *         src.as_ptr() as *const _,
 *         src.len(),
 *     )
 * };
 * assert_eq!(rc, 0);
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 * #include <stdio.h>
 *
 * int example_memcpy(void) {
 *     char dst[16];
 *     const char src[] = "hello";
 *     int rc = nfc_safe_memcpy(dst, sizeof(dst), src, sizeof(src) - 1);
 *     if (rc != NFC_SECURE_SUCCESS) {
 *         fprintf(stderr, "memcpy failed: %s\n", nfc_secure_strerror(rc));
 *         return rc;
 *     }
 *     dst[sizeof(src)-1] = '\0';
 *     printf("copied: %s\n", dst);
 *     return NFC_SECURE_SUCCESS;
 * }
 * ```
 */
int nfc_safe_memcpy(void *dst, size_t dst_size, const void *src, size_t src_size);

/**
 * Like `nfc_safe_memcpy` but safe for overlapping source and
 * destination ranges (semantics equivalent to `memmove`).
 *
 * Returns the same set of `NFC_SECURE_*` error codes used by the
 * memcpy variant.
 *
 * # Safety
 * Both `dst` and `src` must point to valid memory regions for
 * `src_size` bytes. The function allows overlap between the regions.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_safe_memmove;
 * let mut buf = [0u8; 32];
 * // Move 8 bytes forward within same buffer
 * let rc = unsafe { nfc_safe_memmove(buf.as_mut_ptr() as *mut _, 8, buf.as_ptr() as *const _, 8) };
 * assert_eq!(rc, 0);
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 *
 * void example_memmove(void) {
 *     char buf[64];
 *     /* prepare buf */
*nfc_safe_memmove(buf + 2, 32, buf, 32);
*
}
* ```
        * /
    int nfc_safe_memmove(void *dst, size_t dst_size, const void *src, size_t src_size);

/**
 * Securely set `size` bytes at `ptr` to the byte value `val`.
 *
 * When available this function uses platform-provided secure-zeroing
 * or secure-memset routines to avoid having the compiler optimize the
 * write away. Note that some platform primitives (for example
 * `explicit_bzero` or Windows `SecureZeroMemory`) only support
 * zeroing; if the caller requests a non-zero value and the platform
 * exposes no primitive that accepts an arbitrary fill value, the
 * implementation will fall back to a standard `memset` + compiler
 * fence or a volatile-write loop. In that case the call will still
 * perform the requested fill, but it may not benefit from the same
 * platform-provided guarantees as a true secure-zero primitive.
 *
 * Return codes mirror the memcpy/memmove helpers:
 * - `NFC_SECURE_SUCCESS` on success
 * - `NFC_SECURE_ERROR_INVALID` when `ptr` is NULL or a platform
 *   secure API reports failure
 * - `NFC_SECURE_ERROR_RANGE` when `size` is out of acceptable range
 *
 * # Safety
 * The caller must ensure `ptr` is valid for `size` bytes and writable.
 *
 * # Notes
 * When available this function prefers platform primitives that the
 * system guarantees will not be optimized away (C23 `memset_explicit`,
 * `memset_s`, `explicit_bzero`, or `SecureZeroMemory`). If none are
 * present the implementation falls back to a volatile write loop for
 * small buffers and `memset` + compiler fence for larger ones.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_secure_memset;
 * let mut secret = [0xFFu8; 64];
 * let rc = unsafe { nfc_secure_memset(secret.as_mut_ptr() as *mut _, 0, secret.len()) };
 * assert_eq!(rc, 0);
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 *
 * void scrub_secret(void *ptr, size_t len) {
 *     if (nfc_secure_memset(ptr, 0, len) != NFC_SECURE_SUCCESS) {
 *         /* handle error */
*
}
*
}
* ```
        * /
    int nfc_secure_memset(void *ptr, int val, size_t size);

/**
 * Securely zero `size` bytes at `ptr`.
 *
 * This API is explicitly for zeroing secrets. It prefers platform
 * zeroing primitives (C23 `memset_explicit`, `memset_s`,
 * `explicit_bzero`, `SecureZeroMemory`) and will never attempt to fill
 * with non-zero bytes. Use `nfc_secure_memset` when you need to fill
 * with an arbitrary byte value.
 */
int nfc_secure_zero(void *ptr, size_t size);

/**
 * Return a static NUL-terminated message describing `code`.
 *
 * The returned pointer references a static string owned by the
 * library and MUST NOT be freed by the caller.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_secure_strerror;
 * let msg = unsafe { nfc_secure_strerror(0) };
 * // msg points to a static C string; don't free it from Rust
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 * #include <stdio.h>
 *
 * void show_error(int code) {
 *     printf("error: %s\n", nfc_secure_strerror(code));
 * }
 * ```
 */
const char *nfc_secure_strerror(int code);

/**
 * Compute the length of a NUL-terminated C string but never read
 * past `maxlen` bytes.
 *
 * Returns the number of bytes before the first NUL or `0` when
 * `str` is NULL. The return value is bounded by `maxlen`.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_safe_strlen;
 * let s = std::ffi::CString::new("hello").unwrap();
 * let len = unsafe { nfc_safe_strlen(s.as_ptr(), 100) };
 * assert_eq!(len as usize, 5);
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 * #include <stdio.h>
 *
 * void example_strlen(const char *s) {
 *     size_t l = nfc_safe_strlen(s, 100);
 *     printf("len=%zu\n", l);
 * }
 * ```
 */
size_t nfc_safe_strlen(const char *str, size_t maxlen);

/**
 * Inspect `buf` up to `bufsize` bytes and return `1` if a NUL
 * terminator is found, otherwise return `0`.
 *
 * `buf` may be NULL; a NULL pointer yields `0`.
 *
 * Note: this helper operates on raw bytes and does not validate
 * UTF-8 or any multibyte encoding; it simply searches for the NUL
 * byte (0x00) inside the provided byte range.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_is_null_terminated;
 * let buf = ['A' as i8, 0, 'B' as i8];
 * let ok = unsafe { nfc_is_null_terminated(buf.as_ptr() as *const _, 3) };
 * assert_eq!(ok, 1);
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 *
 * int check_buffer(const char *buf, size_t size) {
 *     return nfc_is_null_terminated(buf, size);
 * }
 * ```
 */
int nfc_is_null_terminated(const char *buf, size_t bufsize);

/**
 * Ensure a buffer of size `bufsize` contains a terminating NUL.
 *
 * If no NUL is found within the first `bufsize` bytes the last
 * byte (`buf[bufsize-1]`) is set to `0`. If `buf` is NULL or
 * `bufsize` is zero the function returns immediately.
 *
 * Note: this helper only ensures a NUL byte exists inside the
 * provided range; it does not perform any UTF-8 validation.
 *
 * # Example (Rust, no_run)
 * ```no_run
 * use libnfc_rs::nfc_ensure_null_terminated;
 * let mut buf = [b'A' as i8; 4];
 * unsafe { nfc_ensure_null_terminated(buf.as_mut_ptr() as *mut _, 4) };
 * ```
 *
 * # C Example
 * ```c
 * #include <libnfc_rs.h>
 *
 * void ensure_buf(char *buf, size_t size) {
 *     nfc_ensure_null_terminated(buf, size);
 * }
 * ```
 */
void nfc_ensure_null_terminated(char *buf, size_t bufsize);

#endif /* LIBNFC_RS_H */

/* End of generated header */
