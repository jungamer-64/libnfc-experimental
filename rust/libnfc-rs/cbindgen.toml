language = "C"
namespace = "libnfc_rs"
include_guard = "LIBNFC_RS_H"
pragma_once = true
include_version = true
header = "// This header is generated by cbindgen. Do not edit manually.\n// Regenerate with: cbindgen --config rust/libnfc-rs/cbindgen.toml --crate libnfc-rs --output rust/libnfc-rs/include/libnfc_rs.h\n\n// Manually-provided macros for values that cbindgen cannot emit\n#define LOG_CATEGORY \"libnfc.common\"\n#define MALLOC_LABEL \"malloc\"\n"
trailer = "/* End of generated header */\n"

[parse]
parse_deps = false

[export]
include = [
    "nfc_parse_connstring",
    "nfc_build_connstring",
    "connstring_decode",
    "nfc_get_last_error",
    "nfc_clear_last_error",
    "nfc_set_last_error",
    "nfc_safe_memcpy",
    "nfc_safe_memmove",
    "nfc_secure_memset",
    "nfc_secure_zero",
    "nfc_secure_strerror",
    "nfc_safe_strlen",
    "nfc_is_null_terminated",
    "nfc_ensure_null_terminated",

    "nfc_rs_free",
]

# Explicitly exclude debug-only helpers from the stable header output.
exclude = [
    "nfc_buffers_overlap",
    "nfc_check_suspicious_size",
    "LOG_CATEGORY",
    "MALLOC_LABEL",
]

[fn]
must_use = "warn"

[defines]
# Map Rust cfgs and features to C preprocessor defines so cbindgen can
# wrap feature-gated symbols with appropriate #ifdef guards.
# Keys must be valid TOML strings representing the cfg expression.
"test" = "RUST_TEST"

# Multiple key variants to cover different stringification styles emitted
# by cbindgen when it reports missing defines. This ensures the mapping
# is recognized regardless of spacing or whether `cfg(...)` is included.
"feature = \"nfc_secure\"" = "NFC_SECURE"
"feature=\"nfc_secure\"" = "NFC_SECURE"
"cfg(feature = \"nfc_secure\")" = "NFC_SECURE"
"cfg(feature=\"nfc_secure\")" = "NFC_SECURE"

"feature = \"nfc_secure_debug\"" = "NFC_SECURE_DEBUG"
"feature=\"nfc_secure_debug\"" = "NFC_SECURE_DEBUG"
"cfg(feature = \"nfc_secure_debug\")" = "NFC_SECURE_DEBUG"
"cfg(feature=\"nfc_secure_debug\")" = "NFC_SECURE_DEBUG"

# Build-time detection cfgs emitted by build.rs. Map them to the
# corresponding C preprocessor macros used across the project so
# cbindgen can wrap items with the same guards the C code expects.
"have_memset_explicit" = "HAVE_MEMSET_EXPLICIT"
"cfg(have_memset_explicit)" = "HAVE_MEMSET_EXPLICIT"

"have_memset_s" = "HAVE_MEMSET_S"
"cfg(have_memset_s)" = "HAVE_MEMSET_S"

"have_explicit_bzero" = "HAVE_EXPLICIT_BZERO"
"cfg(have_explicit_bzero)" = "HAVE_EXPLICIT_BZERO"

"have_secure_zero_memory" = "HAVE_SECURE_ZERO_MEMORY"
"cfg(have_secure_zero_memory)" = "HAVE_SECURE_ZERO_MEMORY"

# Also add single-quoted keys as some cbindgen versions stringify
# cfg expressions in slightly different ways; adding both forms is
# harmless and may silence additional missing-define warnings.

# Additional mappings for composite/wrapped cfg expressions that
# cbindgen may emit when parsing attribute expressions. These cover
# forms like `any(...)`, `all(...)`, and `not(...)` that include a
# `feature = "nfc_secure"` sub-expression so the generator can
# correctly map them to the C preprocessor macro `NFC_SECURE`.
"any(feature = \"nfc_secure\")" = "NFC_SECURE"
"any(feature=\"nfc_secure\")" = "NFC_SECURE"
"cfg(any(feature = \"nfc_secure\"))" = "NFC_SECURE"
"cfg(any(feature=\"nfc_secure\"))" = "NFC_SECURE"

"all(feature = \"nfc_secure\")" = "NFC_SECURE"
"all(feature=\"nfc_secure\")" = "NFC_SECURE"
"cfg(all(feature = \"nfc_secure\"))" = "NFC_SECURE"
"cfg(all(feature=\"nfc_secure\"))" = "NFC_SECURE"

"not(feature = \"nfc_secure\")" = "NFC_SECURE"
"not(feature=\"nfc_secure\")" = "NFC_SECURE"
"cfg(not(feature = \"nfc_secure\"))" = "NFC_SECURE"
"cfg(not(feature=\"nfc_secure\"))" = "NFC_SECURE"
