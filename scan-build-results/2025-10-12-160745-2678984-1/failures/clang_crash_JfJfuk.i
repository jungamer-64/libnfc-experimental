# 1 "pn53x.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 387 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "pn53x.c" 2
# 34 "pn53x.c"
# 1 "../../config.h" 1
# 35 "pn53x.c" 2


# 1 "/usr/lib/llvm-18/lib/clang/18/include/inttypes.h" 1 3
# 21 "/usr/lib/llvm-18/lib/clang/18/include/inttypes.h" 3
# 1 "/usr/include/inttypes.h" 1 3 4
# 25 "/usr/include/inttypes.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 394 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 395 "/usr/include/features.h" 2 3 4
# 480 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 481 "/usr/include/features.h" 2 3 4
# 502 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 576 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 577 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 578 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 503 "/usr/include/features.h" 2 3 4
# 526 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 527 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/inttypes.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 1 3 4
# 52 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;
# 332 "/usr/include/inttypes.h" 3 4
typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 351 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ ));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ ));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ ));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ ));
# 22 "/usr/lib/llvm-18/lib/clang/18/include/inttypes.h" 2 3
# 38 "pn53x.c" 2
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3
# 55 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___gnuc_va_list.h" 1 3
# 12 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___gnuc_va_list.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 56 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_list.h" 1 3
# 12 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 61 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_arg.h" 1 3
# 66 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___va_copy.h" 1 3
# 71 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg_va_copy.h" 1 3
# 76 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3
# 39 "pn53x.c" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 29 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 35 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3 4
# 38 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 44 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 45 "/usr/include/stdio.h" 2 3 4








typedef __gnuc_va_list va_list;
# 64 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 85 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;
# 129 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 130 "/usr/include/stdio.h" 2 3 4
# 149 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));
# 184 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 194 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 211 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ )) ;
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 264 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));
# 299 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;
# 334 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ))
  __attribute__ ((__nonnull__ (1)));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 357 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nonnull__ (1)));




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 422 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 438 "/usr/include/stdio.h" 2 3 4
# 463 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") __attribute__ ((__nonnull__ (1)));


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ ));
# 490 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 540 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ ))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 575 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getc (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern int getchar (void);






extern int getc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getchar_unlocked (void);
# 611 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));





extern int putchar (int __c);
# 635 "/usr/include/stdio.h" 3 4
extern int putc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putchar_unlocked (int __c);
# 654 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                                                          __attribute__ ((__nonnull__ (3)));
# 667 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 717 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (2)));





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) __attribute__ ((__nonnull__ (4)));
# 779 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern long int ftell (FILE *__stream) __attribute__ ((__nonnull__ (1)));




extern void rewind (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 803 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern __off_t ftello (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 829 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos)
  __attribute__ ((__nonnull__ (1)));




extern int fsetpos (FILE *__stream, const fpos_t *__pos) __attribute__ ((__nonnull__ (1)));
# 860 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 878 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s) __attribute__ ((__cold__));




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 897 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ))
                                     ;
# 941 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 959 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 976 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}
# 65 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}
# 100 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 977 "/usr/include/stdio.h" 2 3 4
# 40 "pn53x.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3 4
# 24 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 3 4
typedef int wchar_t;
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ )) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 200 "/usr/include/stdlib.h" 3 4
__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 480 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void*)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ )) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void*)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ )) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void*)0), 10);
}
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ )) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 47 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __ino_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;
# 121 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 158 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 185 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 227 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 515 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ ));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ ));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 573 "/usr/include/stdlib.h" 3 4
extern int rand (void) __attribute__ ((__nothrow__ ));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ ));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ ));







extern double drand48 (void) __attribute__ ((__nothrow__ ));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ ));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ ));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ ));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 672 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__))
                                         ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__)) ;


extern void free (void *__ptr) __attribute__ ((__nothrow__ ));
# 718 "/usr/include/stdlib.h" 3 4
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 730 "/usr/include/stdlib.h" 3 4
extern void abort (void) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 756 "/usr/include/stdlib.h" 3 4
extern void exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));
# 768 "/usr/include/stdlib.h" 3 4
extern void _Exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 786 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 827 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 923 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ )) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 960 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (const void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 {




   return (void *) __p;



 }
    }

  return ((void*)0);
}
# 966 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 980 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;
# 1062 "/usr/include/stdlib.h" 3 4
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ ));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ ));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ))
                                      ;

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ ))

                                    ;
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ ));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ ));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ )) ;
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ )) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void*)0));
}
# 1156 "/usr/include/stdlib.h" 2 3 4
# 41 "pn53x.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;
# 187 "/usr/include/string.h" 3 4
extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 407 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 419 "/usr/include/string.h" 3 4
extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 432 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)))


                                          ;
# 42 "pn53x.c" 2


# 1 "../../include/nfc/nfc.h" 1
# 38 "../../include/nfc/nfc.h"
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdbool.h" 1 3
# 39 "../../include/nfc/nfc.h" 2
# 63 "../../include/nfc/nfc.h"
# 1 "../../include/nfc/nfc-types.h" 1
# 36 "../../include/nfc/nfc-types.h"
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3
# 72 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 73 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 112 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_offsetof.h" 1 3
# 113 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 37 "../../include/nfc/nfc-types.h" 2
# 48 "../../include/nfc/nfc-types.h"
typedef struct nfc_context nfc_context;




typedef struct nfc_device nfc_device;




typedef struct nfc_driver nfc_driver;




typedef char nfc_connstring[1024];




typedef enum {





  NP_TIMEOUT_COMMAND,






  NP_TIMEOUT_ATR,




  NP_TIMEOUT_COM,







  NP_HANDLE_CRC,







  NP_HANDLE_PARITY,


  NP_ACTIVATE_FIELD,



  NP_ACTIVATE_CRYPTO1,





  NP_INFINITE_SELECT,



  NP_ACCEPT_INVALID_FRAMES,






  NP_ACCEPT_MULTIPLE_FRAMES,







  NP_AUTO_ISO14443_4,

  NP_EASY_FRAMING,

  NP_FORCE_ISO14443_A,

  NP_FORCE_ISO14443_B,

  NP_FORCE_SPEED_106,
} nfc_property;


#pragma pack(1)





typedef enum {
  NDM_UNDEFINED = 0,
  NDM_PASSIVE,
  NDM_ACTIVE,
} nfc_dep_mode;





typedef struct {

  uint8_t abtNFCID3[10];

  uint8_t btDID;

  uint8_t btBS;

  uint8_t btBR;

  uint8_t btTO;

  uint8_t btPP;

  uint8_t abtGB[48];
  size_t szGB;

  nfc_dep_mode ndm;
} nfc_dep_info;





typedef struct {
  uint8_t abtAtqa[2];
  uint8_t btSak;
  size_t szUidLen;
  uint8_t abtUid[10];
  size_t szAtsLen;
  uint8_t abtAts[254];
} nfc_iso14443a_info;





typedef struct {
  size_t szLen;
  uint8_t btResCode;
  uint8_t abtId[8];
  uint8_t abtPad[8];
  uint8_t abtSysCode[2];
} nfc_felica_info;





typedef struct {

  uint8_t abtPupi[4];

  uint8_t abtApplicationData[4];

  uint8_t abtProtocolInfo[3];

  uint8_t ui8CardIdentifier;
} nfc_iso14443b_info;





typedef struct {

  uint8_t abtDIV[4];

  uint8_t btVerLog;

  uint8_t btConfig;

  size_t szAtrLen;
  uint8_t abtAtr[33];
} nfc_iso14443bi_info;





typedef struct {
  uint8_t abtUID[8];
} nfc_iso14443biclass_info;





typedef struct {
  uint8_t abtUID[8];
} nfc_iso14443b2sr_info;





typedef struct {
  uint8_t abtUID[4];
  uint8_t btProdCode;
  uint8_t btFabCode;
} nfc_iso14443b2ct_info;





typedef struct {
  uint8_t btSensRes[2];
  uint8_t btId[4];
} nfc_jewel_info;





typedef struct {
  size_t szDataLen;
  uint8_t abtData[32];
} nfc_barcode_info;





typedef union {
  nfc_iso14443a_info nai;
  nfc_felica_info nfi;
  nfc_iso14443b_info nbi;
  nfc_iso14443bi_info nii;
  nfc_iso14443b2sr_info nsi;
  nfc_iso14443b2ct_info nci;
  nfc_jewel_info nji;
  nfc_dep_info ndi;
  nfc_barcode_info nti;
  nfc_iso14443biclass_info nhi;
} nfc_target_info;





typedef enum {
  NBR_UNDEFINED = 0,
  NBR_106,
  NBR_212,
  NBR_424,
  NBR_847,
} nfc_baud_rate;





typedef enum {
  NMT_ISO14443A = 1,
  NMT_JEWEL,
  NMT_ISO14443B,
  NMT_ISO14443BI,
  NMT_ISO14443B2SR,
  NMT_ISO14443B2CT,
  NMT_FELICA,
  NMT_DEP,
  NMT_BARCODE,
  NMT_ISO14443BICLASS,
  NMT_END_ENUM = NMT_ISO14443BICLASS,
} nfc_modulation_type;





typedef enum {
  N_TARGET,
  N_INITIATOR,
} nfc_mode;





typedef struct {
  nfc_modulation_type nmt;
  nfc_baud_rate nbr;
} nfc_modulation;





typedef struct {
  nfc_target_info nti;
  nfc_modulation nm;
} nfc_target;


#pragma pack()
# 64 "../../include/nfc/nfc.h" 2
# 84 "../../include/nfc/nfc.h"
           void nfc_init(nfc_context **context) __attribute__((nonnull (1)));
           void nfc_exit(nfc_context *context) __attribute__((nonnull (1)));
           int nfc_register_driver(const nfc_driver *driver);


           nfc_device *nfc_open(nfc_context *context, const nfc_connstring connstring) __attribute__((nonnull (1)));
           void nfc_close(nfc_device *pnd);
           int nfc_abort_command(nfc_device *pnd);
           size_t nfc_list_devices(nfc_context *context, nfc_connstring connstrings[], size_t connstrings_len) __attribute__((nonnull (1)));
           int nfc_idle(nfc_device *pnd);


           int nfc_initiator_init(nfc_device *pnd);
           int nfc_initiator_init_secure_element(nfc_device *pnd);
           int nfc_initiator_select_passive_target(nfc_device *pnd, const nfc_modulation nm, const uint8_t *pbtInitData, const size_t szInitData, nfc_target *pnt);
           int nfc_initiator_list_passive_targets(nfc_device *pnd, const nfc_modulation nm, nfc_target ant[], const size_t szTargets);
           int nfc_initiator_poll_target(nfc_device *pnd, const nfc_modulation *pnmTargetTypes, const size_t szTargetTypes, const uint8_t uiPollNr, const uint8_t uiPeriod, nfc_target *pnt);
           int nfc_initiator_select_dep_target(nfc_device *pnd, const nfc_dep_mode ndm, const nfc_baud_rate nbr, const nfc_dep_info *pndiInitiator, nfc_target *pnt, const int timeout);
           int nfc_initiator_poll_dep_target(nfc_device *pnd, const nfc_dep_mode ndm, const nfc_baud_rate nbr, const nfc_dep_info *pndiInitiator, nfc_target *pnt, const int timeout);
           int nfc_initiator_deselect_target(nfc_device *pnd);
           int nfc_initiator_transceive_bytes(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, int timeout);
           int nfc_initiator_transceive_bits(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar);
           int nfc_initiator_transceive_bytes_timed(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, uint32_t *cycles);
           int nfc_initiator_transceive_bits_timed(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar, uint32_t *cycles);
           int nfc_initiator_target_is_present(nfc_device *pnd, const nfc_target *pnt);


           int nfc_target_init(nfc_device *pnd, nfc_target *pnt, uint8_t *pbtRx, const size_t szRx, int timeout);
           int nfc_target_send_bytes(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, int timeout);
           int nfc_target_receive_bytes(nfc_device *pnd, uint8_t *pbtRx, const size_t szRx, int timeout);
           int nfc_target_send_bits(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar);
           int nfc_target_receive_bits(nfc_device *pnd, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar);


           const char *nfc_strerror(const nfc_device *pnd);
           int nfc_strerror_r(const nfc_device *pnd, char *buf, size_t buflen);
           void nfc_perror(const nfc_device *pnd, const char *s);
           int nfc_device_get_last_error(const nfc_device *pnd);


           const char *nfc_device_get_name(nfc_device *pnd);
           const char *nfc_device_get_connstring(nfc_device *pnd);
           int nfc_device_get_supported_modulation(nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type **const supported_mt);
           int nfc_device_get_supported_baud_rate(nfc_device *pnd, const nfc_modulation_type nmt, const nfc_baud_rate **const supported_br);
           int nfc_device_get_supported_baud_rate_target_mode(nfc_device *pnd, const nfc_modulation_type nmt, const nfc_baud_rate **const supported_br);


           int nfc_device_set_property_int(nfc_device *pnd, const nfc_property property, const int value);
           int nfc_device_set_property_bool(nfc_device *pnd, const nfc_property property, const _Bool bEnable);


           void iso14443a_crc(uint8_t *pbtData, size_t szLen, uint8_t *pbtCrc);
           void iso14443a_crc_append(uint8_t *pbtData, size_t szLen);
           void iso14443b_crc(uint8_t *pbtData, size_t szLen, uint8_t *pbtCrc);
           void iso14443b_crc_append(uint8_t *pbtData, size_t szLen);
           uint8_t *iso14443a_locate_historical_bytes(uint8_t *pbtAts, size_t szAts, size_t *pszTk);

           void nfc_free(void *p);
           const char *nfc_version(void);
           int nfc_device_get_information_about(nfc_device *pnd, char **buf);


           const char *str_nfc_modulation_type(const nfc_modulation_type nmt);
           const char *str_nfc_baud_rate(const nfc_baud_rate nbr);
           int str_nfc_target(char **buf, const nfc_target *pnt, _Bool verbose);
# 45 "pn53x.c" 2
# 1 "../../libnfc/nfc-internal.h" 1
# 36 "../../libnfc/nfc-internal.h"
# 1 "/usr/include/err.h" 1 3 4
# 25 "/usr/include/err.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3 4
# 26 "/usr/include/err.h" 2 3 4








extern void warn (const char *__format, ...)
     __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__cold__));
extern void vwarn (const char *__format, __gnuc_va_list)
     __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__cold__));


extern void warnx (const char *__format, ...)
     __attribute__ ((__format__ (__printf__, 1, 2)));
extern void vwarnx (const char *__format, __gnuc_va_list)
     __attribute__ ((__format__ (__printf__, 1, 0)));


extern void err (int __status, const char *__format, ...)
     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 3))) __attribute__ ((__cold__));
extern void verr (int __status, const char *__format, __gnuc_va_list)
     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 0))) __attribute__ ((__cold__));
extern void errx (int __status, const char *__format, ...)
     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 3))) __attribute__ ((__cold__));
extern void verrx (int __status, const char *, __gnuc_va_list)
     __attribute__ ((__noreturn__, __format__ (__printf__, 2, 0))) __attribute__ ((__cold__));
# 37 "../../libnfc/nfc-internal.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 26 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 2 3 4




struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 33 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 67 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 114 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;





extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ ));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ ));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 39 "../../libnfc/nfc-internal.h" 2




# 1 "../../libnfc/log.h" 1
# 31 "../../libnfc/log.h"
# 1 "../../config.h" 1
# 32 "../../libnfc/log.h" 2


# 1 "../../libnfc/nfc-internal.h" 1
# 35 "../../libnfc/log.h" 2
# 1 "../../libnfc/nfc-secure.h" 1
# 43 "../../libnfc/nfc-secure.h"
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3
# 44 "../../libnfc/nfc-secure.h" 2
# 162 "../../libnfc/nfc-secure.h"
  enum nfc_secure_error
  {
    NFC_SECURE_SUCCESS = 0,
    NFC_SECURE_ERROR_INVALID = -1,
    NFC_SECURE_ERROR_OVERFLOW = -2,
    NFC_SECURE_ERROR_RANGE = -3,
    NFC_SECURE_ERROR_ZERO_SIZE = -4
  };
# 180 "../../libnfc/nfc-secure.h"
  const char *nfc_secure_strerror(int error_code);
# 216 "../../libnfc/nfc-secure.h"
  __attribute__((warn_unused_result))
  int nfc_safe_memcpy(void *dst, size_t dst_size, const void *src, size_t src_size);
# 243 "../../libnfc/nfc-secure.h"
  __attribute__((warn_unused_result))
  int nfc_safe_memmove(void *dst, size_t dst_size, const void *src, size_t src_size);
# 283 "../../libnfc/nfc-secure.h"
  __attribute__((warn_unused_result))
  int nfc_secure_memset(void *ptr, int val, size_t size);
# 447 "../../libnfc/nfc-secure.h"
size_t nfc_safe_strlen(const char *str, size_t maxlen);
# 471 "../../libnfc/nfc-secure.h"
static inline int
nfc_is_null_terminated(const char *buf, size_t bufsize)
{
  if (buf == ((void*)0) || bufsize == 0)
  {
    return 0;
  }

  for (size_t i = 0; i < bufsize; i++)
  {
    if (buf[i] == '\0')
    {
      return 1;
    }
  }
  return 0;
}
# 511 "../../libnfc/nfc-secure.h"
static inline void
nfc_ensure_null_terminated(char *buf, size_t bufsize)
{
  if (buf == ((void*)0) || bufsize == 0)
  {
    return;
  }


  int found_null = 0;
  for (size_t i = 0; i < bufsize; i++)
  {
    if (buf[i] == '\0')
    {
      found_null = 1;
      break;
    }
  }


  if (!found_null)
  {
    buf[bufsize - 1] = '\0';
  }
}
# 36 "../../libnfc/log.h" 2
# 63 "../../libnfc/log.h"
const char *log_priority_to_str(const int priority);
# 75 "../../libnfc/log.h"
void log_init(const nfc_context *context);
void log_exit(void);
void log_put(const uint8_t group, const char *category, const uint8_t priority, const char *format, ...)

    __attribute__((format(printf, 4, 5)))

    ;
# 44 "../../libnfc/nfc-internal.h" 2
# 120 "../../libnfc/nfc-internal.h"
typedef enum {
  NOT_INTRUSIVE,
  INTRUSIVE,
  NOT_AVAILABLE,
} scan_type_enum;

struct nfc_driver {
  const char *name;
  const scan_type_enum scan_type;
  size_t (*scan)(const nfc_context *context, nfc_connstring connstrings[], const size_t connstrings_len);
  struct nfc_device *(*open)(const nfc_context *context, const nfc_connstring connstring);
  void (*close)(struct nfc_device *pnd);
  const char *(*strerror)(const struct nfc_device *pnd);

  int (*initiator_init)(struct nfc_device *pnd);
  int (*initiator_init_secure_element)(struct nfc_device *pnd);
  int (*initiator_select_passive_target)(struct nfc_device *pnd, const nfc_modulation nm, const uint8_t *pbtInitData, const size_t szInitData, nfc_target *pnt);
  int (*initiator_poll_target)(struct nfc_device *pnd, const nfc_modulation *pnmModulations, const size_t szModulations, const uint8_t uiPollNr, const uint8_t btPeriod, nfc_target *pnt);
  int (*initiator_select_dep_target)(struct nfc_device *pnd, const nfc_dep_mode ndm, const nfc_baud_rate nbr, const nfc_dep_info *pndiInitiator, nfc_target *pnt, const int timeout);
  int (*initiator_deselect_target)(struct nfc_device *pnd);
  int (*initiator_transceive_bytes)(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, int timeout);
  int (*initiator_transceive_bits)(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, uint8_t *pbtRxPar);
  int (*initiator_transceive_bytes_timed)(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, uint32_t *cycles);
  int (*initiator_transceive_bits_timed)(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, uint8_t *pbtRxPar, uint32_t *cycles);
  int (*initiator_target_is_present)(struct nfc_device *pnd, const nfc_target *pnt);

  int (*target_init)(struct nfc_device *pnd, nfc_target *pnt, uint8_t *pbtRx, const size_t szRx, int timeout);
  int (*target_send_bytes)(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, int timeout);
  int (*target_receive_bytes)(struct nfc_device *pnd, uint8_t *pbtRx, const size_t szRxLen, int timeout);
  int (*target_send_bits)(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar);
  int (*target_receive_bits)(struct nfc_device *pnd, uint8_t *pbtRx, const size_t szRxLen, uint8_t *pbtRxPar);

  int (*device_set_property_bool)(struct nfc_device *pnd, const nfc_property property, const _Bool bEnable);
  int (*device_set_property_int)(struct nfc_device *pnd, const nfc_property property, const int value);
  int (*get_supported_modulation)(struct nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type **const supported_mt);
  int (*get_supported_baud_rate)(struct nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type nmt, const nfc_baud_rate **const supported_br);
  int (*device_get_information_about)(struct nfc_device *pnd, char **buf);

  int (*abort_command)(struct nfc_device *pnd);
  int (*idle)(struct nfc_device *pnd);
  int (*powerdown)(struct nfc_device *pnd);
};






struct nfc_user_defined_device {
  char name[256];
  nfc_connstring connstring;
  _Bool optional;
};






struct nfc_context {
  _Bool allow_autoscan;
  _Bool allow_intrusive_scan;
  uint32_t log_level;
  struct nfc_user_defined_device user_defined_devices[4];
  unsigned int user_defined_device_count;
};

nfc_context *nfc_context_new(void);
void nfc_context_free(nfc_context *context);





struct nfc_device {
  const nfc_context *context;
  const struct nfc_driver *driver;
  void *driver_data;
  void *chip_data;


  char name[256];

  nfc_connstring connstring;

  _Bool bCrc;

  _Bool bPar;

  _Bool bEasyFraming;

  _Bool bInfiniteSelect;


  _Bool bAutoIso14443_4;

  uint8_t btSupportByte;

  int last_error;
};

nfc_device *nfc_device_new(const nfc_context *context, const nfc_connstring connstring);
void nfc_device_free(nfc_device *dev);

void string_as_boolean(const char *s, _Bool *value);

void iso14443_cascade_uid(const uint8_t abtUID[], const size_t szUID, uint8_t *pbtCascadedUID, size_t *pszCascadedUID);

void prepare_initiator_data(const nfc_modulation nm, uint8_t **ppbtInitiatorData, size_t *pszInitiatorData);

int connstring_decode(const nfc_connstring connstring, const char *driver_name, const char *bus_name, char **pparam1, char **pparam2);
# 46 "pn53x.c" 2

# 1 "./pn53x.h" 1
# 37 "./pn53x.h"
# 1 "./pn53x-internal.h" 1
# 128 "./pn53x-internal.h"
typedef struct {
  uint8_t ui8Code;
  uint8_t ui8CompatFlags;

  const char *abtCommandText;

} pn53x_command;

typedef enum {
  PN53X = 0x00,
  PN531 = 0x01,
  PN532 = 0x02,
  PN533 = 0x04,
  RCS360 = 0x08
} pn53x_type;
# 159 "./pn53x-internal.h"
static const pn53x_command pn53x_commands[] = {

  { 0x00 , PN531 | PN532 | PN533 | RCS360, "Diagnose" },
  { 0x02 , PN531 | PN532 | PN533 | RCS360, "GetFirmwareVersion" },
  { 0x04 , PN531 | PN532 | PN533 | RCS360, "GetGeneralStatus" },
  { 0x06 , PN531 | PN532 | PN533 | RCS360, "ReadRegister" },
  { 0x08 , PN531 | PN532 | PN533 | RCS360, "WriteRegister" },
  { 0x0C , PN531 | PN532 | PN533, "ReadGPIO" },
  { 0x0E , PN531 | PN532 | PN533, "WriteGPIO" },
  { 0x10 , PN531 | PN532 | PN533, "SetSerialBaudRate" },
  { 0x12 , PN531 | PN532 | PN533 | RCS360, "SetParameters" },
  { 0x14 , PN531 | PN532, "SAMConfiguration" },
  { 0x16 , PN531 | PN532, "PowerDown" },
  { 0x18 , PN533 | RCS360, "AlparCommandForTDA" },


  { 0x32 , PN531 | PN532 | PN533 | RCS360, "RFConfiguration" },
  { 0x58 , PN531 | PN532 | PN533, "RFRegulationTest" },


  { 0x56 , PN531 | PN532 | PN533 | RCS360, "InJumpForDEP" },
  { 0x46 , PN531 | PN532 | PN533, "InJumpForPSL" },
  { 0x4A , PN531 | PN532 | PN533 | RCS360, "InListPassiveTarget" },
  { 0x50 , PN531 | PN532 | PN533, "InATR" },
  { 0x4E , PN531 | PN532 | PN533, "InPSL" },
  { 0x40 , PN531 | PN532 | PN533, "InDataExchange" },
  { 0x42 , PN531 | PN532 | PN533 | RCS360, "InCommunicateThru" },
  { 0x38 , PN533, "InQuartetByteExchange" },
  { 0x44 , PN531 | PN532 | PN533 | RCS360, "InDeselect" },
  { 0x52 , PN531 | PN532 | PN533 | RCS360, "InRelease" },
  { 0x54 , PN531 | PN532 | PN533, "InSelect" },
  { 0x60 , PN532, "InAutoPoll" },
  { 0x48 , PN533, "InActivateDeactivatePaypass" },


  { 0x8C , PN531 | PN532 | PN533, "TgInitAsTarget" },
  { 0x92 , PN531 | PN532 | PN533, "TgSetGeneralBytes" },
  { 0x86 , PN531 | PN532 | PN533, "TgGetData" },
  { 0x8E , PN531 | PN532 | PN533, "TgSetData" },
  { 0x96 , PN533, "TgSetDataSecure" },
  { 0x94 , PN531 | PN532 | PN533, "TgSetMetaData" },
  { 0x98 , PN533, "TgSetMetaDataSecure" },
  { 0x88 , PN531 | PN532 | PN533, "TgGetInitiatorCommand" },
  { 0x90 , PN531 | PN532 | PN533, "TgResponseToInitiator" },
  { 0x8A , PN531 | PN532 | PN533, "TgGetTargetStatus" },
};
# 218 "./pn53x-internal.h"
typedef struct {
  uint16_t ui16Address;
  const char *abtRegisterText;
  const char *abtRegisterDescription;
} pn53x_register;
# 346 "./pn53x-internal.h"
static const pn53x_register pn53x_registers[] = {
  { 0x6301 , "PN53X_REG_CIU_Mode", "Defines general modes for transmitting and receiving" },
  { 0x6302 , "PN53X_REG_CIU_TxMode", "Defines the transmission data rate and framing during transmission" },
  { 0x6303 , "PN53X_REG_CIU_RxMode", "Defines the transmission data rate and framing during receiving" },
  { 0x6304 , "PN53X_REG_CIU_TxControl", "Controls the logical behaviour of the antenna driver pins TX1 and TX2" },
  { 0x6305 , "PN53X_REG_CIU_TxAuto", "Controls the settings of the antenna driver" },
  { 0x6306 , "PN53X_REG_CIU_TxSel", "Selects the internal sources for the antenna driver" },
  { 0x6307 , "PN53X_REG_CIU_RxSel", "Selects internal receiver settings" },
  { 0x6308 , "PN53X_REG_CIU_RxThreshold", "Selects thresholds for the bit decoder" },
  { 0x6309 , "PN53X_REG_CIU_Demod", "Defines demodulator settings" },
  { 0x630A , "PN53X_REG_CIU_FelNFC1", "Defines the length of the valid range for the received frame" },
  { 0x630B , "PN53X_REG_CIU_FelNFC2", "Defines the length of the valid range for the received frame" },
  { 0x630C , "PN53X_REG_CIU_MifNFC", "Controls the communication in ISO/IEC 14443/MIFARE and NFC target mode at 106 kbit/s" },
  { 0x630D , "PN53X_REG_CIU_ManualRCV", "Allows manual fine tuning of the internal receiver" },
  { 0x630E , "PN53X_REG_CIU_TypeB", "Configure the ISO/IEC 14443 type B" },


  { 0x6311 , "PN53X_REG_CIU_CRCResultMSB", "Shows the actual MSB values of the CRC calculation" },
  { 0x6312 , "PN53X_REG_CIU_CRCResultLSB", "Shows the actual LSB values of the CRC calculation" },
  { 0x6313 , "PN53X_REG_CIU_GsNOFF", "Selects the conductance of the antenna driver pins TX1 and TX2 for load modulation when own RF field is switched OFF" },
  { 0x6314 , "PN53X_REG_CIU_ModWidth", "Controls the setting of the width of the Miller pause" },
  { 0x6315 , "PN53X_REG_CIU_TxBitPhase", "Bit synchronization at 106 kbit/s" },
  { 0x6316 , "PN53X_REG_CIU_RFCfg", "Configures the receiver gain and RF level" },
  { 0x6317 , "PN53X_REG_CIU_GsNOn", "Selects the conductance of the antenna driver pins TX1 and TX2 for modulation, when own RF field is switched ON" },
  { 0x6318 , "PN53X_REG_CIU_CWGsP", "Selects the conductance of the antenna driver pins TX1 and TX2 when not in modulation phase" },
  { 0x6319 , "PN53X_REG_CIU_ModGsP", "Selects the conductance of the antenna driver pins TX1 and TX2 when in modulation phase" },
  { 0x631A , "PN53X_REG_CIU_TMode", "Defines settings for the internal timer" },
  { 0x631B , "PN53X_REG_CIU_TPrescaler", "Defines settings for the internal timer" },
  { 0x631C , "PN53X_REG_CIU_TReloadVal_hi", "Describes the 16-bit long timer reload value (Higher 8 bits)" },
  { 0x631D , "PN53X_REG_CIU_TReloadVal_lo", "Describes the 16-bit long timer reload value (Lower 8 bits)" },
  { 0x631E , "PN53X_REG_CIU_TCounterVal_hi", "Describes the 16-bit long timer actual value (Higher 8 bits)" },
  { 0x631F , "PN53X_REG_CIU_TCounterVal_lo", "Describes the 16-bit long timer actual value (Lower 8 bits)" },

  { 0x6321 , "PN53X_REG_CIU_TestSel1", "General test signals configuration" },
  { 0x6322 , "PN53X_REG_CIU_TestSel2", "General test signals configuration and PRBS control" },
  { 0x6323 , "PN53X_REG_CIU_TestPinEn", "Enables test signals output on pins." },
  { 0x6324 , "PN53X_REG_CIU_TestPinValue", "Defines the values for the 8-bit parallel bus when it is used as I/O bus" },
  { 0x6325 , "PN53X_REG_CIU_TestBus", "Shows the status of the internal test bus" },
  { 0x6326 , "PN53X_REG_CIU_AutoTest", "Controls the digital self-test" },
  { 0x6327 , "PN53X_REG_CIU_Version", "Shows the CIU version" },
  { 0x6328 , "PN53X_REG_CIU_AnalogTest", "Controls the pins AUX1 and AUX2" },
  { 0x6329 , "PN53X_REG_CIU_TestDAC1", "Defines the test value for the TestDAC1" },
  { 0x632A , "PN53X_REG_CIU_TestDAC2", "Defines the test value for the TestDAC2" },
  { 0x632B , "PN53X_REG_CIU_TestADC", "Show the actual value of ADC I and Q" },



  { 0x632F , "PN53X_REG_CIU_RFlevelDet", "Power down of the RF level detector" },
  { 0x6330 , "PN53X_REG_CIU_SIC_CLK_en", "Enables the use of secure IC clock on P34 / SIC_CLK" },
  { 0x6331 , "PN53X_REG_CIU_Command", "Starts and stops the command execution" },
  { 0x6332 , "PN53X_REG_CIU_CommIEn", "Control bits to enable and disable the passing of interrupt requests" },
  { 0x6333 , "PN53X_REG_CIU_DivIEn", "Controls bits to enable and disable the passing of interrupt requests" },
  { 0x6334 , "PN53X_REG_CIU_CommIrq", "Contains common CIU interrupt request flags" },
  { 0x6335 , "PN53X_REG_CIU_DivIrq", "Contains miscellaneous interrupt request flags" },
  { 0x6336 , "PN53X_REG_CIU_Error", "Error flags showing the error status of the last command executed" },
  { 0x6337 , "PN53X_REG_CIU_Status1", "Contains status flags of the CRC, Interrupt Request System and FIFO buffer" },
  { 0x6338 , "PN53X_REG_CIU_Status2", "Contain status flags of the receiver, transmitter and Data Mode Detector" },
  { 0x6339 , "PN53X_REG_CIU_FIFOData", "In- and output of 64 byte FIFO buffer" },
  { 0x633A , "PN53X_REG_CIU_FIFOLevel", "Indicates the number of bytes stored in the FIFO" },
  { 0x633B , "PN53X_REG_CIU_WaterLevel", "Defines the thresholds for FIFO under- and overflow warning" },
  { 0x633C , "PN53X_REG_CIU_Control", "Contains miscellaneous control bits" },
  { 0x633D , "PN53X_REG_CIU_BitFraming", "Adjustments for bit oriented frames" },
  { 0x633E , "PN53X_REG_CIU_Coll", "Defines the first bit collision detected on the RF interface" },


  { 0xFFFC , "PN53X_SFR_P3CFGA", "Port 3 configuration" },
  { 0xFFFD , "PN53X_SFR_P3CFGB", "Port 3 configuration" },
  { 0xFFB0 , "PN53X_SFR_P3", "Port 3 value" },
  { 0xFFF4 , "PN53X_SFR_P7CFGA", "Port 7 configuration" },
  { 0xFFF5 , "PN53X_SFR_P7CFGB", "Port 7 configuration" },
  { 0xFFF7 , "PN53X_SFR_P7", "Port 7 value" },
};
# 38 "./pn53x.h" 2
# 135 "./pn53x.h"
typedef enum {
  NORMAL,
  POWERDOWN,
  LOWVBAT
} pn53x_power_mode;





typedef enum {
  IDLE,
  INITIATOR,
  TARGET,
} pn53x_operating_mode;





typedef enum {
  PSM_NORMAL = 0x01,
  PSM_VIRTUAL_CARD = 0x02,
  PSM_WIRED_CARD = 0x03,
  PSM_DUAL_CARD = 0x04
} pn532_sam_mode;






struct pn53x_io {
  int (*send)(struct nfc_device *pnd, const uint8_t *pbtData, const size_t szData, int timeout);
  int (*receive)(struct nfc_device *pnd, uint8_t *pbtData, const size_t szDataLen, int timeout);
};
# 182 "./pn53x.h"
struct pn53x_data {

  pn53x_type type;

  char firmware_text[22];

  pn53x_power_mode power_mode;

  pn53x_operating_mode operating_mode;

  nfc_target *current_target;

  pn532_sam_mode sam_mode;

  const struct pn53x_io *io;

  uint8_t last_status_byte;

  uint8_t ui8TxBits;

  uint8_t ui8Parameters;

  uint8_t last_command;

  int16_t timer_correction;

  uint16_t timer_prescaler;

  uint8_t wb_data[((0x633E - 0x6301) + 1)];
  uint8_t wb_mask[((0x633E - 0x6301) + 1)];
  _Bool wb_trigged;

  int timeout_command;

  int timeout_atr;

  int timeout_communication;

  nfc_modulation_type *supported_modulation_as_initiator;
  nfc_modulation_type *supported_modulation_as_target;
  _Bool progressive_field;
};







typedef enum {

  PM_UNDEFINED = -1,

  PM_ISO14443A_106 = 0x00,

  PM_FELICA_212 = 0x01,

  PM_FELICA_424 = 0x02,

  PM_ISO14443B_106 = 0x03,

  PM_JEWEL_106 = 0x04,

  PM_BARCODE_106 = 0x05,

  PM_ISO14443B_212 = 0x06,

  PM_ISO14443B_424 = 0x07,

  PM_ISO14443B_847 = 0x08,
} pn53x_modulation;





typedef enum {

  PTT_UNDEFINED = -1,

  PTT_GENERIC_PASSIVE_106 = 0x00,

  PTT_GENERIC_PASSIVE_212 = 0x01,

  PTT_GENERIC_PASSIVE_424 = 0x02,

  PTT_ISO14443_4B_106 = 0x03,

  PTT_JEWEL_106 = 0x04,

  PTT_MIFARE = 0x10,

  PTT_FELICA_212 = 0x11,

  PTT_FELICA_424 = 0x12,

  PTT_ISO14443_4A_106 = 0x20,

  PTT_ISO14443_4B_TCL_106 = 0x23,

  PTT_DEP_PASSIVE_106 = 0x40,

  PTT_DEP_PASSIVE_212 = 0x41,

  PTT_DEP_PASSIVE_424 = 0x42,

  PTT_DEP_ACTIVE_106 = 0x80,

  PTT_DEP_ACTIVE_212 = 0x81,

  PTT_DEP_ACTIVE_424 = 0x82,
} pn53x_target_type;





typedef enum {

  PTM_NORMAL = 0x00,

  PTM_PASSIVE_ONLY = 0x01,

  PTM_DEP_ONLY = 0x02,

  PTM_ISO14443_4_PICC_ONLY = 0x04
} pn53x_target_mode;

extern const uint8_t pn53x_ack_frame[6];
extern const uint8_t pn53x_nack_frame[6];

int pn53x_init(struct nfc_device *pnd);
int pn53x_transceive(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRxLen, int timeout);

int pn53x_set_parameters(struct nfc_device *pnd, const uint8_t ui8Value, const _Bool bEnable);
int pn53x_set_tx_bits(struct nfc_device *pnd, const uint8_t ui8Bits);
int pn53x_wrap_frame(const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtFrame);
int pn53x_unwrap_frame(const uint8_t *pbtFrame, const size_t szFrameBits, uint8_t *pbtRx, uint8_t *pbtRxPar);
int pn53x_decode_target_data(const uint8_t *pbtRawData, size_t szRawData,
                             pn53x_type chip_type, nfc_modulation_type nmt,
                             nfc_target_info *pnti);
int pn53x_read_register(struct nfc_device *pnd, uint16_t ui16Reg, uint8_t *ui8Value);
int pn53x_write_register(struct nfc_device *pnd, uint16_t ui16Reg, uint8_t ui8SymbolMask, uint8_t ui8Value);
int pn53x_decode_firmware_version(struct nfc_device *pnd);
int pn53x_set_property_int(struct nfc_device *pnd, const nfc_property property, const int value);
int pn53x_set_property_bool(struct nfc_device *pnd, const nfc_property property, const _Bool bEnable);

int pn53x_check_communication(struct nfc_device *pnd);
int pn53x_idle(struct nfc_device *pnd);


int pn53x_initiator_init(struct nfc_device *pnd);
void pn53x_initiator_init_iclass_modulation(struct nfc_device *pnd);
int pn532_initiator_init_secure_element(struct nfc_device *pnd);
int pn53x_initiator_select_passive_target(struct nfc_device *pnd,
                                          const nfc_modulation nm,
                                          const uint8_t *pbtInitData, const size_t szInitData,
                                          nfc_target *pnt);
int pn53x_initiator_poll_target(struct nfc_device *pnd,
                                const nfc_modulation *pnmModulations, const size_t szModulations,
                                const uint8_t uiPollNr, const uint8_t uiPeriod,
                                nfc_target *pnt);
int pn53x_initiator_select_dep_target(struct nfc_device *pnd,
                                      const nfc_dep_mode ndm, const nfc_baud_rate nbr,
                                      const nfc_dep_info *pndiInitiator,
                                      nfc_target *pnt,
                                      const int timeout);
int pn53x_initiator_transceive_bits(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits,
                                    const uint8_t *pbtTxPar, uint8_t *pbtRx, uint8_t *pbtRxPar);
int pn53x_initiator_transceive_bytes(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx,
                                     uint8_t *pbtRx, const size_t szRx, int timeout);
int pn53x_initiator_transceive_bits_timed(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits,
                                          const uint8_t *pbtTxPar, uint8_t *pbtRx, uint8_t *pbtRxPar, uint32_t *cycles);
int pn53x_initiator_transceive_bytes_timed(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx,
                                           uint8_t *pbtRx, const size_t szRx, uint32_t *cycles);
int pn53x_initiator_deselect_target(struct nfc_device *pnd);
int pn53x_initiator_target_is_present(struct nfc_device *pnd, const nfc_target *pnt);
int pn53x_initiator_select_passive_target_ext(struct nfc_device *pnd, const nfc_modulation nm,
                                              const uint8_t *pbtInitData, const size_t szInitData,
                                              nfc_target *pnt, int timeout);


int pn53x_target_init(struct nfc_device *pnd, nfc_target *pnt, uint8_t *pbtRx, const size_t szRxLen, int timeout);
int pn53x_target_receive_bits(struct nfc_device *pnd, uint8_t *pbtRx, const size_t szRxLen, uint8_t *pbtRxPar);
int pn53x_target_receive_bytes(struct nfc_device *pnd, uint8_t *pbtRx, const size_t szRxLen, int timeout);
int pn53x_target_send_bits(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar);
int pn53x_target_send_bytes(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, int timeout);


const char *pn53x_strerror(const struct nfc_device *pnd);


int pn53x_SetParameters(struct nfc_device *pnd, const uint8_t ui8Value);
int pn532_SAMConfiguration(struct nfc_device *pnd, const pn532_sam_mode mode, int timeout);
int pn53x_PowerDown(struct nfc_device *pnd);
int pn53x_InListPassiveTarget(struct nfc_device *pnd, const pn53x_modulation pmInitModulation,
                              const uint8_t szMaxTargets, const uint8_t *pbtInitiatorData,
                              const size_t szInitiatorDataLen, uint8_t *pbtTargetsData, size_t *pszTargetsData,
                              int timeout);
int pn53x_InDeselect(struct nfc_device *pnd, const uint8_t ui8Target);
int pn53x_InRelease(struct nfc_device *pnd, const uint8_t ui8Target);
int pn53x_InAutoPoll(struct nfc_device *pnd, const pn53x_target_type *ppttTargetTypes, const size_t szTargetTypes,
                     const uint8_t btPollNr, const uint8_t btPeriod, nfc_target *pntTargets,
                     const int timeout);
int pn53x_InJumpForDEP(struct nfc_device *pnd,
                       const nfc_dep_mode ndm, const nfc_baud_rate nbr,
                       const uint8_t *pbtPassiveInitiatorData,
                       const uint8_t *pbtNFCID3i,
                       const uint8_t *pbtGB, const size_t szGB,
                       nfc_target *pnt,
                       const int timeout);
int pn53x_TgInitAsTarget(struct nfc_device *pnd, pn53x_target_mode ptm,
                         const uint8_t *pbtMifareParams,
                         const uint8_t *pbtTkt, size_t szTkt,
                         const uint8_t *pbtFeliCaParams,
                         const uint8_t *pbtNFCID3t, const uint8_t *pbtGB, const size_t szGB,
                         uint8_t *pbtRx, const size_t szRxLen, uint8_t *pbtModeByte, int timeout);


int pn53x_RFConfiguration__RF_field(struct nfc_device *pnd, _Bool bEnable);
int pn53x_RFConfiguration__Various_timings(struct nfc_device *pnd, const uint8_t fATR_RES_Timeout, const uint8_t fRetryTimeout);
int pn53x_RFConfiguration__MaxRtyCOM(struct nfc_device *pnd, const uint8_t MaxRtyCOM);
int pn53x_RFConfiguration__MaxRetries(struct nfc_device *pnd, const uint8_t MxRtyATR, const uint8_t MxRtyPSL, const uint8_t MxRtyPassiveActivation);


int pn53x_check_ack_frame(struct nfc_device *pnd, const uint8_t *pbtRxFrame, const size_t szRxFrameLen);
int pn53x_check_error_frame(struct nfc_device *pnd, const uint8_t *pbtRxFrame, const size_t szRxFrameLen);
int pn53x_build_frame(uint8_t *pbtFrame, size_t *pszFrame, const uint8_t *pbtData, const size_t szData);
int pn53x_get_supported_modulation(nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type **const supported_mt);
int pn53x_get_supported_baud_rate(nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type nmt, const nfc_baud_rate **const supported_br);
int pn53x_get_information_about(nfc_device *pnd, char **pbuf);

void *pn53x_data_new(struct nfc_device *pnd, const struct pn53x_io *io);
void pn53x_data_free(struct nfc_device *pnd);
# 48 "pn53x.c" 2


# 1 "../../libnfc/mirror-subr.h" 1
# 39 "../../libnfc/mirror-subr.h"
uint8_t mirror(uint8_t bt);
uint32_t mirror32(uint32_t ui32Bits);
uint64_t mirror64(uint64_t ui64Bits);
# 51 "pn53x.c" 2




const uint8_t pn53x_ack_frame[] = {0x00, 0x00, 0xff, 0x00, 0xff, 0x00};
const uint8_t pn53x_nack_frame[] = {0x00, 0x00, 0xff, 0xff, 0x00, 0x00};
static const uint8_t pn53x_error_frame[] = {0x00, 0x00, 0xff, 0x01, 0xff, 0x7f, 0x81, 0x00};
const nfc_baud_rate pn532_iso14443a_supported_baud_rates[] = {NBR_424, NBR_212, NBR_106, 0};
const nfc_baud_rate pn533_iso14443a_supported_baud_rates[] = {NBR_847, NBR_424, NBR_212, NBR_106, 0};
const nfc_baud_rate pn53x_felica_supported_baud_rates[] = {NBR_424, NBR_212, 0};
const nfc_baud_rate pn53x_dep_supported_baud_rates[] = {NBR_424, NBR_212, NBR_106, 0};
const nfc_baud_rate pn53x_jewel_supported_baud_rates[] = {NBR_106, 0};
const nfc_baud_rate pn53x_barcode_supported_baud_rates[] = {NBR_106, 0};
const nfc_baud_rate pn532_iso14443b_supported_baud_rates[] = {NBR_106, 0};
const nfc_baud_rate pn533_iso14443b_supported_baud_rates[] = {NBR_847, NBR_424, NBR_212, NBR_106, 0};
const nfc_modulation_type pn53x_supported_modulation_as_target[] = {NMT_ISO14443A, NMT_FELICA, NMT_DEP, 0};


int pn53x_reset_settings(struct nfc_device *pnd);
int pn53x_writeback_register(struct nfc_device *pnd);

nfc_modulation pn53x_ptt_to_nm(const pn53x_target_type ptt);
pn53x_modulation pn53x_nm_to_pm(const nfc_modulation nm);
pn53x_target_type pn53x_nm_to_ptt(const nfc_modulation nm);

void *pn53x_current_target_new(const struct nfc_device *pnd, const nfc_target *pnt);
void pn53x_current_target_free(const struct nfc_device *pnd);
_Bool pn53x_current_target_is(const struct nfc_device *pnd, const nfc_target *pnt);


int pn53x_init(struct nfc_device *pnd)
{
  int res = 0;

  if ((res = pn53x_decode_firmware_version(pnd)) < 0)
  {
    return res;
  }

  if (!((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator)
  {
    ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator = malloc(sizeof(nfc_modulation_type) * (NMT_END_ENUM + 1));
    if (!((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator)
      return -80;
    int nbSupportedModulation = 0;
    if ((pnd->btSupportByte & 0x01))
    {
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_ISO14443A;
      nbSupportedModulation++;
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_FELICA;
      nbSupportedModulation++;
    }
    if (pnd->btSupportByte & 0x02)
    {
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_ISO14443B;
      nbSupportedModulation++;
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_ISO14443BI;
      nbSupportedModulation++;
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_ISO14443B2SR;
      nbSupportedModulation++;
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_ISO14443B2CT;
      nbSupportedModulation++;
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_ISO14443BICLASS;
      nbSupportedModulation++;
    }
    if (((struct pn53x_data *)(pnd->chip_data))->type != PN531)
    {
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_JEWEL;
      nbSupportedModulation++;
      ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_BARCODE;
      nbSupportedModulation++;
    }
    ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = NMT_DEP;
    nbSupportedModulation++;
    ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator[nbSupportedModulation] = 0;
  }

  if (!((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_target)
  {
    ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_target = (nfc_modulation_type *)pn53x_supported_modulation_as_target;
  }
# 140 "pn53x.c"
  if ((res = pn53x_SetParameters(pnd, 0x04 | 0x10)) < 0)
  {
    return res;
  }

  if ((res = pn53x_reset_settings(pnd)) < 0)
  {
    return res;
  }
  return 0;
}

int pn53x_reset_settings(struct nfc_device *pnd)
{
  int res = 0;

  ((struct pn53x_data *)(pnd->chip_data))->ui8TxBits = 0;
  if ((res = pn53x_write_register(pnd, 0x633D, 0x07, 0x00)) < 0)
  {
    return res;
  }

  if ((res = pn53x_set_property_bool(pnd, NP_HANDLE_CRC, 1)) < 0)
    return res;
  if ((res = pn53x_set_property_bool(pnd, NP_HANDLE_PARITY, 1)) < 0)
    return res;

  if ((res = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 1)) < 0)
    return res;

  if ((res = pn53x_set_property_bool(pnd, NP_ACTIVATE_CRYPTO1, 0)) < 0)
    return res;

  return 0;
}
# 187 "pn53x.c"
static void pn53x_extract_status_byte(struct nfc_device *pnd, const uint8_t *pbtTx,
                                      const uint8_t *pbtRx, _Bool *mi)
{
  uint8_t cmd = pbtTx[0];


  switch (cmd)
  {
  case 0x16:
  case 0x40:
  case 0x42:
  case 0x46:
  case 0x4E:
  case 0x50:
  case 0x54:
  case 0x56:
  case 0x86:
  case 0x88:
  case 0x8E:
  case 0x90:
  case 0x92:
  case 0x94:
    if (pbtRx[0] & 0x80)
    {
      abort();
    }
    *mi = pbtRx[0] & 0x40;
    ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = pbtRx[0] & 0x3f;
    return;

  case 0x00:
    if (pbtTx[1] == 0x06)
    {

      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = pbtRx[0] & 0x3f;
    }
    else
    {
      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = 0;
    }
    return;

  case 0x44:
  case 0x52:
    if (((struct pn53x_data *)(pnd->chip_data))->type == RCS360)
    {

      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = 0;
    }
    else
    {
      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = pbtRx[0] & 0x3f;
    }
    return;

  case 0x06:
  case 0x08:
    if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
    {

      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = pbtRx[0] & 0x3f;
    }
    else
    {
      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = 0;
    }
    return;

  default:
    ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = 0;
    return;
  }
}
# 270 "pn53x.c"
static int pn53x_translate_error_code(uint8_t status_byte)
{
  switch (status_byte)
  {
  case 0:
    return 0;


  case 0x01:
  case 0x02:
  case 0x03:
  case 0x04:
  case 0x05:
  case 0x06:
  case 0x0b:
  case 0x0a:
  case 0x12:
  case 0x25:
  case 0x2e:
  case 0x2c:
  case 0x13:
  case 0x23:
  case 0x2a:
    return -20;


  case 0x07:
  case 0x2d:
  case 0x09:
  case 0x0d:
  case 0x0e:
    return -90;


  case 0x10:
  case 0x26:
  case 0x27:
  case 0x18:
    return -2;


  case 0x29:
  case 0x2b:
    return -10;


  case 0x14:
    return -30;

  default:
    return -90;
  }
}
# 338 "pn53x.c"
static int pn53x_handle_mi(struct nfc_device *pnd, const uint8_t *pbtTx,
                           uint8_t *pbtRx, size_t szRx, int *res, int timeout)
{
  _Bool mi = 1;

  while (mi)
  {
    int res2;
    uint8_t abtRx2[264];


    if ((res2 = ((struct pn53x_data *)(pnd->chip_data))->io->send(pnd, pbtTx, 2, timeout)) < 0)
    {
      return res2;
    }

    if ((res2 = ((struct pn53x_data *)(pnd->chip_data))->io->receive(pnd, abtRx2, sizeof(abtRx2), timeout)) < 0)
    {
      return res2;
    }

    mi = abtRx2[0] & 0x40;


    if ((size_t)(*res + res2 - 1) > szRx)
    {
      ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = 0x07;
      return -90;
    }



    if (nfc_safe_memcpy(pbtRx + *res, szRx - *res, abtRx2 + 1, res2 - 1) < 0)
      return -90;
    pbtRx[0] = abtRx2[0];
    *res += res2 - 1;
  }

  return 0;
}

int pn53x_transceive(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRxLen, int timeout)
{

  if (!pnd || !pbtTx || szTx == 0)
  {
    log_put(3, "libnfc.chip.pn53x", 1, "Invalid parameters in pn53x_transceive");
    return -2;
  }

  _Bool mi = 0;
  int res = 0;
  if (((struct pn53x_data *)(pnd->chip_data))->wb_trigged)
  {
    if ((res = pn53x_writeback_register(pnd)) < 0)
    {
      return res;
    }
  }

  do { for (size_t i=0; i<(sizeof(pn53x_commands)/sizeof(pn53x_command)); i++) { if ( pbtTx[0] == pn53x_commands[i].ui8Code ) { log_put( 3, "libnfc.chip.pn53x", 3, "%s", pn53x_commands[i].abtCommandText ); break; } } } while(0);
  if (timeout > 0)
  {
    log_put(3, "libnfc.chip.pn53x", 3, "Timeout value: %d", timeout);
  }
  else if (timeout == 0)
  {
    log_put(3, "libnfc.chip.pn53x", 3, "%s", "No timeout");
  }
  else if (timeout == -1)
  {
    timeout = ((struct pn53x_data *)(pnd->chip_data))->timeout_command;
  }
  else
  {
    log_put(3, "libnfc.chip.pn53x", 1, "Invalid timeout value: %d", timeout);
  }

  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);


  if (szRxLen == 0 || !pbtRx)
  {
    pbtRx = abtRx;
  }
  else
  {
    szRx = szRxLen;
  }


  if ((res = ((struct pn53x_data *)(pnd->chip_data))->io->send(pnd, pbtTx, szTx, timeout)) < 0)
  {
    return res;
  }


  ((struct pn53x_data *)(pnd->chip_data))->last_command = pbtTx[0];


  if ((((struct pn53x_data *)(pnd->chip_data))->type == PN532) && (0x8C == pbtTx[0]))
  {

    ((struct pn53x_data *)(pnd->chip_data))->power_mode = POWERDOWN;
  }

  if ((res = ((struct pn53x_data *)(pnd->chip_data))->io->receive(pnd, pbtRx, szRx, timeout)) < 0)
  {
    return res;
  }

  if ((((struct pn53x_data *)(pnd->chip_data))->type == PN532) && (0x8C == pbtTx[0]))
  {

    ((struct pn53x_data *)(pnd->chip_data))->power_mode = NORMAL;
  }


  pn53x_extract_status_byte(pnd, pbtTx, pbtRx, &mi);


  if (mi)
  {
    int mi_result = pn53x_handle_mi(pnd, pbtTx, pbtRx, szRx, &res, timeout);
    if (mi_result < 0)
    {
      pnd->last_error = mi_result;
      return mi_result;
    }
  }

  szRx = (size_t)res;


  res = pn53x_translate_error_code(((struct pn53x_data *)(pnd->chip_data))->last_status_byte);


  if (res == -10)
  {
    pn53x_current_target_free(pnd);
  }


  if (res == 0)
  {
    res = (int)szRx;
  }

  if (res < 0)
  {
    pnd->last_error = res;
    log_put(3, "libnfc.chip.pn53x", 3, "Chip error: \"%s\" (%02x), returned error: \"%s\" (%d))", pn53x_strerror(pnd), ((struct pn53x_data *)(pnd->chip_data))->last_status_byte, nfc_strerror(pnd), res);
  }
  else
  {
    pnd->last_error = 0;
  }
  return res;
}

int pn53x_set_parameters(struct nfc_device *pnd, const uint8_t ui8Parameter, const _Bool bEnable)
{
  uint8_t ui8Value = (bEnable) ? (((struct pn53x_data *)(pnd->chip_data))->ui8Parameters | ui8Parameter) : (((struct pn53x_data *)(pnd->chip_data))->ui8Parameters & ~(ui8Parameter));
  if (ui8Value != ((struct pn53x_data *)(pnd->chip_data))->ui8Parameters)
  {
    return pn53x_SetParameters(pnd, ui8Value);
  }
  return 0;
}

int pn53x_set_tx_bits(struct nfc_device *pnd, const uint8_t ui8Bits)
{

  if (((struct pn53x_data *)(pnd->chip_data))->ui8TxBits != ui8Bits)
  {
    int res = 0;

    if ((res = pn53x_write_register(pnd, 0x633D, 0x07, ui8Bits)) < 0)
      return res;


    ((struct pn53x_data *)(pnd->chip_data))->ui8TxBits = ui8Bits;
  }
  return 0;
}

int pn53x_wrap_frame(const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar,
                     uint8_t *pbtFrame)
{
  uint8_t btData;
  uint32_t uiBitPos;
  uint32_t uiDataPos = 0;
  size_t szBitsLeft = szTxBits;
  size_t szFrameBits = 0;


  if (szBitsLeft == 0)
    return -90;


  if (szBitsLeft < 9)
  {
    *pbtFrame = *pbtTx;
    szFrameBits = szTxBits;
    return szFrameBits;
  }

  szFrameBits = szTxBits + (szTxBits / 8);






  while (1)
  {

    uint8_t btFrame = 0;

    for (uiBitPos = 0; uiBitPos < 8; uiBitPos++)
    {

      btData = mirror(pbtTx[uiDataPos]);
      btFrame |= (btData >> uiBitPos);

      *pbtFrame = mirror(btFrame);

      btFrame = (btData << (8 - uiBitPos));
      btFrame |= ((pbtTxPar[uiDataPos] & 0x01) << (7 - uiBitPos));

      pbtFrame++;
      *pbtFrame = mirror(btFrame);

      uiDataPos++;

      if (szBitsLeft < 9)
        return szFrameBits;
      szBitsLeft -= 8;
    }

    pbtFrame++;
  }
}

int pn53x_unwrap_frame(const uint8_t *pbtFrame, const size_t szFrameBits, uint8_t *pbtRx, uint8_t *pbtRxPar)
{
  uint8_t btFrame;
  uint8_t btData;
  uint8_t uiBitPos;
  uint32_t uiDataPos = 0;
  uint8_t *pbtFramePos = (uint8_t *)pbtFrame;
  size_t szBitsLeft = szFrameBits;
  size_t szRxBits = 0;


  if (szBitsLeft == 0)
    return -90;


  if (szBitsLeft < 9)
  {
    *pbtRx = *pbtFrame;
    szRxBits = szFrameBits;
    return szRxBits;
  }

  szRxBits = szFrameBits - (szFrameBits / 9);



  while (1)
  {
    for (uiBitPos = 0; uiBitPos < 8; uiBitPos++)
    {
      btFrame = mirror(pbtFramePos[uiDataPos]);
      btData = (btFrame << uiBitPos);
      btFrame = mirror(pbtFramePos[uiDataPos + 1]);
      btData |= (btFrame >> (8 - uiBitPos));
      pbtRx[uiDataPos] = mirror(btData);
      if (pbtRxPar != ((void*)0))
        pbtRxPar[uiDataPos] = ((btFrame >> (7 - uiBitPos)) & 0x01);

      uiDataPos++;

      if (szBitsLeft < 9)
        return szRxBits;
      szBitsLeft -= 9;
    }

    pbtFramePos++;
  }
}

int pn53x_decode_target_data(const uint8_t *pbtRawData, size_t szRawData, pn53x_type type, nfc_modulation_type nmt,
                             nfc_target_info *pnti)
{
  uint8_t szAttribRes;
  const uint8_t *pbtUid;

  switch (nmt)
  {
  case NMT_ISO14443A:

    pbtRawData++;


    if (type == PN531)
    {
      pnti->nai.abtAtqa[1] = *(pbtRawData++);
      pnti->nai.abtAtqa[0] = *(pbtRawData++);
    }
    else
    {
      pnti->nai.abtAtqa[0] = *(pbtRawData++);
      pnti->nai.abtAtqa[1] = *(pbtRawData++);
    }
    pnti->nai.btSak = *(pbtRawData++);

    pnti->nai.szUidLen = *(pbtRawData++);
    pbtUid = pbtRawData;
    pbtRawData += pnti->nai.szUidLen;


    if (szRawData > (pnti->nai.szUidLen + 5))
    {
      pnti->nai.szAtsLen = ((*(pbtRawData++)) - 1);

      int copy_result = nfc_safe_memcpy(pnti->nai.abtAts, sizeof(pnti->nai.abtAts), pbtRawData, pnti->nai.szAtsLen);
      if (copy_result < 0)
      {
        log_put(3, "libnfc.chip.pn53x", 1, "ATS copy failed: buffer overflow prevented");
        return -90;
      }
    }
    else
    {
      pnti->nai.szAtsLen = 0;
    }



    if ((pnti->nai.szUidLen == 8) && (pbtUid[0] == 0x88))
    {
      pnti->nai.szUidLen = 7;
      if (nfc_safe_memcpy(pnti->nai.abtUid, sizeof(pnti->nai.abtUid), pbtUid + 1, 7) < 0)
        return -90;

    }
    else if (pnti->nai.szUidLen > 10)
    {
      pnti->nai.szUidLen = 10;
      if (nfc_safe_memcpy(pnti->nai.abtUid, sizeof(pnti->nai.abtUid), pbtUid + 1, 3) < 0)
        return -90;
      if (nfc_safe_memcpy(pnti->nai.abtUid + 3, sizeof(pnti->nai.abtUid) - 3, pbtUid + 5, 3) < 0)
        return -90;
      if (nfc_safe_memcpy(pnti->nai.abtUid + 6, sizeof(pnti->nai.abtUid) - 6, pbtUid + 8, 4) < 0)
        return -90;
    }
    else
    {

      if (nfc_safe_memcpy(pnti->nai.abtUid, sizeof(pnti->nai.abtUid), pbtUid, pnti->nai.szUidLen) < 0)
        return -90;
    }
    break;

  case NMT_ISO14443B:

    pbtRawData++;


    pbtRawData++;


    if (nfc_safe_memcpy(pnti->nbi.abtPupi, sizeof(pnti->nbi.abtPupi), pbtRawData, 4) < 0)
      return -90;
    pbtRawData += 4;


    if (nfc_safe_memcpy(pnti->nbi.abtApplicationData, sizeof(pnti->nbi.abtApplicationData), pbtRawData, 4) < 0)
      return -90;
    pbtRawData += 4;


    if (nfc_safe_memcpy(pnti->nbi.abtProtocolInfo, sizeof(pnti->nbi.abtProtocolInfo), pbtRawData, 3) < 0)
      return -90;
    pbtRawData += 3;


    szAttribRes = *(pbtRawData++);
    if (szAttribRes)
    {
      pnti->nbi.ui8CardIdentifier = *(pbtRawData++);
    }
    break;

  case NMT_ISO14443BI:

    pbtRawData++;
    if (*pbtRawData != 0x07)
    {

      return -90;
    }
    pbtRawData++;

    if (nfc_safe_memcpy(pnti->nii.abtDIV, sizeof(pnti->nii.abtDIV), pbtRawData, 4) < 0)
      return -90;
    pbtRawData += 4;
    pnti->nii.btVerLog = *(pbtRawData++);
    if (pnti->nii.btVerLog & 0x80)
    {

      pnti->nii.btConfig = *(pbtRawData++);
      if (pnti->nii.btConfig & 0x40)
      {

        if (nfc_safe_memcpy(pnti->nii.abtAtr, sizeof(pnti->nii.abtAtr), pbtRawData, szRawData - 8) < 0)
          return -90;
        pnti->nii.szAtrLen = szRawData - 8;
      }
    }
    break;

  case NMT_ISO14443B2SR:

    if (nfc_safe_memcpy(pnti->nsi.abtUID, sizeof(pnti->nsi.abtUID), pbtRawData, 8) < 0)
      return -90;
    break;

  case NMT_ISO14443BICLASS:

    for (uint8_t i = 0; i < 8; ++i)
      pnti->nhi.abtUID[7 - i] = pbtRawData[i];
    break;

  case NMT_ISO14443B2CT:

    if (nfc_safe_memcpy(pnti->nci.abtUID, sizeof(pnti->nci.abtUID), pbtRawData, 2) < 0)
      return -90;
    pbtRawData += 2;

    pnti->nci.btProdCode = *(pbtRawData++);
    pnti->nci.btFabCode = *(pbtRawData++);

    if (nfc_safe_memcpy(pnti->nci.abtUID + 2, sizeof(pnti->nci.abtUID) - 2, pbtRawData, 2) < 0)
      return -90;
    break;

  case NMT_FELICA:

    pbtRawData++;


    pnti->nfi.szLen = *(pbtRawData++);
    pnti->nfi.btResCode = *(pbtRawData++);

    if (nfc_safe_memcpy(pnti->nfi.abtId, sizeof(pnti->nfi.abtId), pbtRawData, 8) < 0)
      return -90;
    pbtRawData += 8;

    if (nfc_safe_memcpy(pnti->nfi.abtPad, sizeof(pnti->nfi.abtPad), pbtRawData, 8) < 0)
      return -90;
    pbtRawData += 8;

    if (pnti->nfi.szLen > 18)
    {

      if (nfc_safe_memcpy(pnti->nfi.abtSysCode, sizeof(pnti->nfi.abtSysCode), pbtRawData, 2) < 0)
        return -90;
    }
    break;
  case NMT_JEWEL:

    pbtRawData++;


    if (nfc_safe_memcpy(pnti->nji.btSensRes, sizeof(pnti->nji.btSensRes), pbtRawData, 2) < 0)
      return -90;
    pbtRawData += 2;

    if (nfc_safe_memcpy(pnti->nji.btId, sizeof(pnti->nji.btId), pbtRawData, 4) < 0)
      return -90;
    break;
  case NMT_BARCODE:
    pnti->nti.szDataLen = szRawData;

    if (nfc_safe_memcpy(pnti->nti.abtData, sizeof(pnti->nti.abtData), pbtRawData, szRawData) < 0)
      return -90;
    break;

  case NMT_DEP:
    return -90;
  }
  return 0;
}

static int
pn53x_ReadRegister(struct nfc_device *pnd, uint16_t ui16RegisterAddress, uint8_t *ui8Value)
{
  uint8_t abtCmd[] = {0x06, ui16RegisterAddress >> 8, ui16RegisterAddress & 0xff};
  uint8_t abtRegValue[2];
  size_t szRegValue = sizeof(abtRegValue);
  int res = 0;

  do { for (size_t i=0; i<(sizeof(pn53x_registers)/sizeof(pn53x_register)); i++) { if ( ui16RegisterAddress == pn53x_registers[i].ui16Address ) { log_put( 3, "libnfc.chip.pn53x", 3, "%s (%s)", pn53x_registers[i].abtRegisterText, pn53x_registers[i].abtRegisterDescription ); break; } } } while(0);
  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), abtRegValue, szRegValue, -1)) < 0)
  {
    return res;
  }
  if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
  {

    *ui8Value = abtRegValue[1];
  }
  else
  {
    *ui8Value = abtRegValue[0];
  }
  return 0;
}

int pn53x_read_register(struct nfc_device *pnd, uint16_t ui16RegisterAddress, uint8_t *ui8Value)
{
  return pn53x_ReadRegister(pnd, ui16RegisterAddress, ui8Value);
}

static int
pn53x_WriteRegister(struct nfc_device *pnd, const uint16_t ui16RegisterAddress, const uint8_t ui8Value)
{
  uint8_t abtCmd[] = {0x08, ui16RegisterAddress >> 8, ui16RegisterAddress & 0xff, ui8Value};
  do { for (size_t i=0; i<(sizeof(pn53x_registers)/sizeof(pn53x_register)); i++) { if ( ui16RegisterAddress == pn53x_registers[i].ui16Address ) { log_put( 3, "libnfc.chip.pn53x", 3, "%s (%s)", pn53x_registers[i].abtRegisterText, pn53x_registers[i].abtRegisterDescription ); break; } } } while(0);
  return pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1);
}

int pn53x_write_register(struct nfc_device *pnd, const uint16_t ui16RegisterAddress, const uint8_t ui8SymbolMask, const uint8_t ui8Value)
{
  if ((ui16RegisterAddress < 0x6301) || (ui16RegisterAddress > 0x633E))
  {

    if (ui8SymbolMask != 0xff)
    {
      int res = 0;
      uint8_t ui8CurrentValue;
      if ((res = pn53x_read_register(pnd, ui16RegisterAddress, &ui8CurrentValue)) < 0)
        return res;
      uint8_t ui8NewValue = ((ui8Value & ui8SymbolMask) | (ui8CurrentValue & (~ui8SymbolMask)));
      if (ui8NewValue != ui8CurrentValue)
      {
        return pn53x_WriteRegister(pnd, ui16RegisterAddress, ui8NewValue);
      }
    }
    else
    {
      return pn53x_WriteRegister(pnd, ui16RegisterAddress, ui8Value);
    }
  }
  else
  {

    const int internal_address = ui16RegisterAddress - 0x6301;
    ((struct pn53x_data *)(pnd->chip_data))->wb_data[internal_address] = (((struct pn53x_data *)(pnd->chip_data))->wb_data[internal_address] & ((struct pn53x_data *)(pnd->chip_data))->wb_mask[internal_address] & (~ui8SymbolMask)) | (ui8Value & ui8SymbolMask);
    ((struct pn53x_data *)(pnd->chip_data))->wb_mask[internal_address] = ((struct pn53x_data *)(pnd->chip_data))->wb_mask[internal_address] | ui8SymbolMask;
    ((struct pn53x_data *)(pnd->chip_data))->wb_trigged = 1;
  }
  return 0;
}

int pn53x_writeback_register(struct nfc_device *pnd)
{
  int res = 0;

  uint8_t abtReadRegisterCmd[264]; size_t __abtReadRegisterCmd_n = 0;
  do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x06; } while (0);


  ((struct pn53x_data *)(pnd->chip_data))->wb_trigged = 0;
  for (size_t n = 0; n < ((0x633E - 0x6301) + 1); n++)
  {
    if ((((struct pn53x_data *)(pnd->chip_data))->wb_mask[n]) && (((struct pn53x_data *)(pnd->chip_data))->wb_mask[n] != 0xff))
    {

      const uint16_t pn53x_register_address = 0x6301 + n;
      do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = pn53x_register_address >> 8; } while (0);
      do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = pn53x_register_address & 0xff; } while (0);
    }
  }

  if ((__abtReadRegisterCmd_n) > 1)
  {

    uint8_t abtRes[264];
    size_t szRes = sizeof(abtRes);

    if ((res = pn53x_transceive(pnd, abtReadRegisterCmd, (__abtReadRegisterCmd_n), abtRes, szRes, -1)) < 0)
    {
      return res;
    }
    size_t i = 0;
    if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
    {

      i = 1;
    }
    for (size_t n = 0; n < ((0x633E - 0x6301) + 1); n++)
    {
      if ((((struct pn53x_data *)(pnd->chip_data))->wb_mask[n]) && (((struct pn53x_data *)(pnd->chip_data))->wb_mask[n] != 0xff))
      {
        ((struct pn53x_data *)(pnd->chip_data))->wb_data[n] = ((((struct pn53x_data *)(pnd->chip_data))->wb_data[n] & ((struct pn53x_data *)(pnd->chip_data))->wb_mask[n]) | (abtRes[i] & (~((struct pn53x_data *)(pnd->chip_data))->wb_mask[n])));
        if (((struct pn53x_data *)(pnd->chip_data))->wb_data[n] != abtRes[i])
        {

          ((struct pn53x_data *)(pnd->chip_data))->wb_mask[n] = 0xff;
        }
        else
        {
          ((struct pn53x_data *)(pnd->chip_data))->wb_mask[n] = 0x00;
        }
        i++;
      }
    }
  }

  uint8_t abtWriteRegisterCmd[264]; size_t __abtWriteRegisterCmd_n = 0;
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x08; } while (0);
  for (size_t n = 0; n < ((0x633E - 0x6301) + 1); n++)
  {
    if (((struct pn53x_data *)(pnd->chip_data))->wb_mask[n] == 0xff)
    {
      const uint16_t pn53x_register_address = 0x6301 + n;
      do { for (size_t i=0; i<(sizeof(pn53x_registers)/sizeof(pn53x_register)); i++) { if ( pn53x_register_address == pn53x_registers[i].ui16Address ) { log_put( 3, "libnfc.chip.pn53x", 3, "%s (%s)", pn53x_registers[i].abtRegisterText, pn53x_registers[i].abtRegisterDescription ); break; } } } while(0);
      do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = pn53x_register_address >> 8; } while (0);
      do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = pn53x_register_address & 0xff; } while (0);
      do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = ((struct pn53x_data *)(pnd->chip_data))->wb_data[n]; } while (0);

      ((struct pn53x_data *)(pnd->chip_data))->wb_mask[n] = 0x00;
    }
  }

  if ((__abtWriteRegisterCmd_n) > 1)
  {

    if ((res = pn53x_transceive(pnd, abtWriteRegisterCmd, (__abtWriteRegisterCmd_n), ((void*)0), 0, -1)) < 0)
    {
      return res;
    }
  }
  return 0;
}

int pn53x_decode_firmware_version(struct nfc_device *pnd)
{
  const uint8_t abtCmd[] = {0x02};
  uint8_t abtFw[4];
  size_t szFwLen = sizeof(abtFw);
  int res = 0;
  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), abtFw, szFwLen, -1)) < 0)
  {
    return res;
  }
  szFwLen = (size_t)res;

  if (szFwLen == 2)
  {
    ((struct pn53x_data *)(pnd->chip_data))->type = PN531;
  }
  else if (szFwLen == 4)
  {
    if (abtFw[0] == 0x32)
    {

      ((struct pn53x_data *)(pnd->chip_data))->type = PN532;
    }
    else if (abtFw[0] == 0x33)
    {

      if (abtFw[1] == 0x01)
      {

        ((struct pn53x_data *)(pnd->chip_data))->type = RCS360;
      }
      else
      {
        ((struct pn53x_data *)(pnd->chip_data))->type = PN533;
      }
    }
    else
    {

      return -8;
    }
  }
  else
  {

    return -8;
  }

  switch (((struct pn53x_data *)(pnd->chip_data))->type)
  {
  case PN531:
    snprintf(((struct pn53x_data *)(pnd->chip_data))->firmware_text, sizeof(((struct pn53x_data *)(pnd->chip_data))->firmware_text), "PN531 v%d.%d", abtFw[0], abtFw[1]);
    pnd->btSupportByte = 0x01 | 0x04;
    break;
  case PN532:
    snprintf(((struct pn53x_data *)(pnd->chip_data))->firmware_text, sizeof(((struct pn53x_data *)(pnd->chip_data))->firmware_text), "PN532 v%d.%d", abtFw[1], abtFw[2]);
    pnd->btSupportByte = abtFw[3];
    break;
  case PN533:
  case RCS360:
    snprintf(((struct pn53x_data *)(pnd->chip_data))->firmware_text, sizeof(((struct pn53x_data *)(pnd->chip_data))->firmware_text), "PN533 v%d.%d", abtFw[1], abtFw[2]);
    pnd->btSupportByte = abtFw[3];
    break;
  case PN53X:

    break;
  }
  return 0;
}

static uint8_t
pn53x_int_to_timeout(const int ms)
{
  uint8_t res = 0;
  if (ms)
  {
    res = 0x10;
    for (int i = 3280; i > 1; i /= 2)
    {
      if (ms > i)
        break;
      res--;
    }
  }
  return res;
}

int pn53x_set_property_int(struct nfc_device *pnd, const nfc_property property, const int value)
{
  switch (property)
  {
  case NP_TIMEOUT_COMMAND:
    ((struct pn53x_data *)(pnd->chip_data))->timeout_command = value;
    break;
  case NP_TIMEOUT_ATR:
    ((struct pn53x_data *)(pnd->chip_data))->timeout_atr = value;
    return pn53x_RFConfiguration__Various_timings(pnd, pn53x_int_to_timeout(((struct pn53x_data *)(pnd->chip_data))->timeout_atr), pn53x_int_to_timeout(((struct pn53x_data *)(pnd->chip_data))->timeout_communication));
  case NP_TIMEOUT_COM:
    ((struct pn53x_data *)(pnd->chip_data))->timeout_communication = value;
    return pn53x_RFConfiguration__Various_timings(pnd, pn53x_int_to_timeout(((struct pn53x_data *)(pnd->chip_data))->timeout_atr), pn53x_int_to_timeout(((struct pn53x_data *)(pnd->chip_data))->timeout_communication));

  case NP_HANDLE_CRC:
  case NP_HANDLE_PARITY:
  case NP_ACTIVATE_FIELD:
  case NP_ACTIVATE_CRYPTO1:
  case NP_INFINITE_SELECT:
  case NP_ACCEPT_INVALID_FRAMES:
  case NP_ACCEPT_MULTIPLE_FRAMES:
  case NP_AUTO_ISO14443_4:
  case NP_EASY_FRAMING:
  case NP_FORCE_ISO14443_A:
  case NP_FORCE_ISO14443_B:
  case NP_FORCE_SPEED_106:
    return -2;
  }
  return 0;
}
# 1116 "pn53x.c"
static int
pn53x_set_handle_crc(struct nfc_device *pnd, _Bool bEnable)
{
  if (bEnable == pnd->bCrc)
  {
    return 0;
  }


  uint8_t btValue = bEnable ? 0x80 : 0x00;
  int res;

  if ((res = pn53x_write_register(pnd, 0x6302, 0x80, btValue)) < 0)
    return res;
  if ((res = pn53x_write_register(pnd, 0x6303, 0x80, btValue)) < 0)
    return res;

  pnd->bCrc = bEnable;
  return 0;
}
# 1146 "pn53x.c"
static int
pn53x_set_force_iso14443a(struct nfc_device *pnd, _Bool bEnable)
{
  if (!bEnable)
  {
    return 0;
  }

  int res;


  if ((res = pn53x_write_register(pnd, 0x6302, 0x03, 0x00)) < 0)
  {
    return res;
  }
  if ((res = pn53x_write_register(pnd, 0x6303, 0x03, 0x00)) < 0)
  {
    return res;
  }


  return pn53x_write_register(pnd, 0x6305, 0x40, 0x40);
}
# 1179 "pn53x.c"
static int
pn53x_set_force_iso14443b(struct nfc_device *pnd, _Bool bEnable)
{
  if (!bEnable)
  {
    return 0;
  }

  int res;


  if ((res = pn53x_write_register(pnd, 0x6302, 0x03, 0x03)) < 0)
  {
    return res;
  }
  return pn53x_write_register(pnd, 0x6303, 0x03, 0x03);
}
# 1206 "pn53x.c"
static int
pn53x_set_force_speed_106(struct nfc_device *pnd, _Bool bEnable)
{
  if (!bEnable)
  {
    return 0;
  }

  int res;


  if ((res = pn53x_write_register(pnd, 0x6302, 0x70, 0x00)) < 0)
  {
    return res;
  }
  return pn53x_write_register(pnd, 0x6303, 0x70, 0x00);
}

int pn53x_set_property_bool(struct nfc_device *pnd, const nfc_property property, const _Bool bEnable)
{
  uint8_t btValue;
  int res = 0;
  switch (property)
  {
  case NP_HANDLE_CRC:
    return pn53x_set_handle_crc(pnd, bEnable);

  case NP_HANDLE_PARITY:

    if (bEnable == pnd->bPar)

      return 0;
    btValue = (bEnable) ? 0x00 : 0x10;
    if ((res = pn53x_write_register(pnd, 0x630D, 0x10, btValue)) < 0)
      return res;
    pnd->bPar = bEnable;
    return 0;

  case NP_EASY_FRAMING:
    pnd->bEasyFraming = bEnable;
    return 0;

  case NP_ACTIVATE_FIELD:
    return pn53x_RFConfiguration__RF_field(pnd, bEnable);

  case NP_ACTIVATE_CRYPTO1:
    btValue = (bEnable) ? 0x08 : 0x00;
    return pn53x_write_register(pnd, 0x6338, 0x08, btValue);

  case NP_INFINITE_SELECT:



    pnd->bInfiniteSelect = bEnable;
    return pn53x_RFConfiguration__MaxRetries(pnd,
                                             (bEnable) ? 0xff : 0x00,
                                             (bEnable) ? 0xff : 0x01,
                                             (bEnable) ? 0xff : 0x02
    );

  case NP_ACCEPT_INVALID_FRAMES:
    btValue = (bEnable) ? 0x08 : 0x00;
    return pn53x_write_register(pnd, 0x6303, 0x08, btValue);

  case NP_ACCEPT_MULTIPLE_FRAMES:
    btValue = (bEnable) ? 0x04 : 0x00;
    return pn53x_write_register(pnd, 0x6303, 0x04, btValue);

  case NP_AUTO_ISO14443_4:
    if (bEnable == pnd->bAutoIso14443_4)

      return 0;
    pnd->bAutoIso14443_4 = bEnable;
    return pn53x_set_parameters(pnd, 0x10, bEnable);

  case NP_FORCE_ISO14443_A:
    return pn53x_set_force_iso14443a(pnd, bEnable);

  case NP_FORCE_ISO14443_B:
    return pn53x_set_force_iso14443b(pnd, bEnable);

  case NP_FORCE_SPEED_106:
    return pn53x_set_force_speed_106(pnd, bEnable);

  case NP_TIMEOUT_COMMAND:
  case NP_TIMEOUT_ATR:
  case NP_TIMEOUT_COM:
    return -2;
  }

  return -2;
}

int pn53x_idle(struct nfc_device *pnd)
{
  int res = 0;
  switch (((struct pn53x_data *)(pnd->chip_data))->operating_mode)
  {
  case TARGET:


    if ((res = pn53x_InRelease(pnd, 0)) < 0)
    {
      return res;
    }
    if ((((struct pn53x_data *)(pnd->chip_data))->type == PN532) && (pnd->driver->powerdown))
    {

      if ((res = pnd->driver->powerdown(pnd)) < 0)
      {
        return res;
      }
    }
    break;
  case INITIATOR:

    if ((res = pn53x_InRelease(pnd, 0)) < 0)
    {
      return res;
    }

    if ((res = nfc_device_set_property_bool(pnd, NP_ACTIVATE_FIELD, 0)) < 0)
    {
      return res;
    }
    if ((((struct pn53x_data *)(pnd->chip_data))->type == PN532) && (pnd->driver->powerdown))
    {

      if ((res = pnd->driver->powerdown(pnd)) < 0)
      {
        return res;
      }
    }
    break;
  case IDLE:
    break;
  };

  pn53x_current_target_free(pnd);
  ((struct pn53x_data *)(pnd->chip_data))->operating_mode = IDLE;
  return 0;
}

int pn53x_check_communication(struct nfc_device *pnd)
{
  const uint8_t abtCmd[] = {0x00, 0x00, 'l', 'i', 'b', 'n', 'f', 'c'};
  const uint8_t abtExpectedRx[] = {0x00, 'l', 'i', 'b', 'n', 'f', 'c'};
  uint8_t abtRx[sizeof(abtExpectedRx)];
  size_t szRx = sizeof(abtRx);
  int res = 0;

  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), abtRx, szRx, 500)) < 0)
    return res;
  szRx = (size_t)res;
  if ((sizeof(abtExpectedRx) == szRx) && (0 == memcmp(abtRx, abtExpectedRx, sizeof(abtExpectedRx))))
    return 0;

  return -1;
}

int pn53x_initiator_init(struct nfc_device *pnd)
{
  pn53x_reset_settings(pnd);
  int res;
  if (((struct pn53x_data *)(pnd->chip_data))->sam_mode != PSM_NORMAL)
  {
    if ((res = pn532_SAMConfiguration(pnd, PSM_NORMAL, -1)) < 0)
    {
      return res;
    }
  }


  if ((res = pn53x_write_register(pnd, 0x633C, 0x10, 0x10)) < 0)
    return res;

  ((struct pn53x_data *)(pnd->chip_data))->operating_mode = INITIATOR;
  return 0;
}


void pn53x_initiator_init_iclass_modulation(struct nfc_device *pnd)
{






  pn53x_WriteRegister(pnd, 0x6302, 0x03);





  pn53x_WriteRegister(pnd, 0x6303, 0x0B);



  pn53x_WriteRegister(pnd, 0x630D, 0x10);



  pn53x_WriteRegister(pnd, 0x6316, 0x70);



  pn53x_WriteRegister(pnd, 0x6313, 0x88);



  pn53x_WriteRegister(pnd, 0x6317, 0xf8);



  pn53x_WriteRegister(pnd, 0x6318, 0x3f);



  pn53x_WriteRegister(pnd, 0x6319, 0x10);



  pn53x_WriteRegister(pnd, 0x631C, 0x69);



  pn53x_WriteRegister(pnd, 0x631D, 0xf0);
}

int pn532_initiator_init_secure_element(struct nfc_device *pnd)
{
  return pn532_SAMConfiguration(pnd, PSM_WIRED_CARD, -1);
}
# 1457 "pn53x.c"
static int
pn53x_select_iso14443b_target(struct nfc_device *pnd,
                              const nfc_modulation nm,
                              const uint8_t *pbtInitData, const size_t szInitData,
                              uint8_t *abtTargetsData, size_t *szTargetsData,
                              nfc_target *nttmp,
                              int timeout)
{
  int res = 0;

  if (((struct pn53x_data *)(pnd->chip_data))->type == RCS360)
  {

    pnd->last_error = -8;
    return pnd->last_error;
  }


  if ((res = nfc_device_set_property_bool(pnd, NP_FORCE_ISO14443_B, 1)) < 0)
    return res;
  if ((res = nfc_device_set_property_bool(pnd, NP_FORCE_SPEED_106, 1)) < 0)
    return res;
  if ((res = nfc_device_set_property_bool(pnd, NP_HANDLE_CRC, 1)) < 0)
    return res;
  if ((res = nfc_device_set_property_bool(pnd, NP_EASY_FRAMING, 0)) < 0)
    return res;

  _Bool found = 0;
  do
  {
    if (nm.nmt == NMT_ISO14443B2SR)
    {

      uint8_t abtInitiate[] = "\x06\x00";
      size_t szInitiateLen = 2;
      uint8_t abtSelect[] = {0x0e, 0x00};
      uint8_t abtRx[1];
      uint8_t *pbtInitData_local = (uint8_t *)"\x0b";
      size_t szInitData_local = 1;


      if ((res = pn53x_write_register(pnd, 0x6305, 0xef, 0x07)) < 0)
        return res;
      if ((res = pn53x_write_register(pnd, 0x6318, 0x3f, 0x3f)) < 0)
        return res;
      if ((res = pn53x_write_register(pnd, 0x6319, 0x3f, 0x12)) < 0)
        return res;


      if ((res = pn53x_initiator_transceive_bytes(pnd, abtInitiate, szInitiateLen, abtRx, sizeof(abtRx), timeout)) < 0)
      {
        if ((res == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
          continue;
        return res;
      }

      abtSelect[1] = abtRx[0];
      if ((res = pn53x_initiator_transceive_bytes(pnd, abtSelect, sizeof(abtSelect), abtRx, sizeof(abtRx), timeout)) < 0)
        return res;

      if ((res = pn53x_initiator_transceive_bytes(pnd, pbtInitData_local, szInitData_local, abtTargetsData, *szTargetsData, timeout)) < 0)
      {
        if ((res == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
          continue;
        return res;
      }
      *szTargetsData = (size_t)res;
    }
    else if (nm.nmt == NMT_ISO14443B2CT)
    {

      const uint8_t abtReqt[] = {0x10};
      uint8_t *pbtInitData_local = (uint8_t *)"\x9F\xFF\xFF";
      size_t szInitData_local = 3;


      if ((res = pn53x_initiator_transceive_bytes(pnd, abtReqt, sizeof(abtReqt), abtTargetsData + 2, *szTargetsData - 2, timeout)) < 0)
      {
        if ((res == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
          continue;
        return res;
      }

      if ((res = pn53x_initiator_transceive_bytes(pnd, pbtInitData_local, szInitData_local, abtTargetsData, *szTargetsData, timeout)) < 0)
      {
        if ((res == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
          continue;
        return res;
      }

      *szTargetsData = (size_t)res;
      if (*szTargetsData != 2)
        return 0;


      uint8_t abtRead[] = {0xC4};
      if ((res = pn53x_initiator_transceive_bytes(pnd, abtRead, sizeof(abtRead), abtTargetsData + 4, *szTargetsData - 4, timeout)) < 0)
        return res;

      *szTargetsData = 6;
    }
    else if (nm.nmt == NMT_ISO14443BICLASS)
    {

      pn53x_initiator_init_iclass_modulation(pnd);

      uint8_t abtReqt[] = {0x0a};
      uint8_t abtAnticol[11];


      if (pn53x_initiator_transceive_bytes(pnd, abtReqt, sizeof(abtReqt), ((void*)0), 0, timeout) < 0)
      {
        log_put(3, "libnfc.chip.pn53x", 3, "got expected timeout on iClass activate all");
      }


      abtReqt[0] = 0x0c;
      abtAnticol[0] = 0x81;
      if ((res = pn53x_initiator_transceive_bytes(pnd, abtReqt, sizeof(abtReqt), &abtAnticol[1], sizeof(abtAnticol) - 1, timeout)) < 0)
      {
        log_put(3, "libnfc.chip.pn53x", 3, "timeout on iClass anticol");
        return res;
      }


      if ((res = pn53x_initiator_transceive_bytes(pnd, abtAnticol, 9, abtTargetsData, 10, timeout)) < 0)
      {
        log_put(3, "libnfc.chip.pn53x", 3, "timeout on iClass get UID");
        return res;
      }

      log_put(3, "libnfc.chip.pn53x", 3, "iClass raw UID: %02x %02x %02x %02x %02x %02x %02x %02x",
              abtTargetsData[0], abtTargetsData[1], abtTargetsData[2], abtTargetsData[3],
              abtTargetsData[4], abtTargetsData[5], abtTargetsData[6], abtTargetsData[7]);
      *szTargetsData = 8;

      nttmp->nm = nm;
      if ((res = pn53x_decode_target_data(abtTargetsData, *szTargetsData, ((struct pn53x_data *)(pnd->chip_data))->type, nm.nmt, &(nttmp->nti))) < 0)
        return res;
    }
    else
    {

      if ((res = pn53x_initiator_transceive_bytes(pnd, pbtInitData, szInitData, abtTargetsData, *szTargetsData, timeout)) < 0)
      {
        if ((res == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
          continue;
        return res;
      }
      *szTargetsData = (size_t)res;
    }

    nttmp->nm = nm;
    if ((res = pn53x_decode_target_data(abtTargetsData, *szTargetsData, ((struct pn53x_data *)(pnd->chip_data))->type, nm.nmt, &(nttmp->nti))) < 0)
      return res;

    if (nm.nmt == NMT_ISO14443BI)
    {

      uint8_t abtAttrib[6];
      if (nfc_safe_memcpy(abtAttrib, sizeof(abtAttrib), abtTargetsData, sizeof(abtAttrib)) < 0)
        return -90;
      abtAttrib[1] = 0x0f;
      if ((res = pn53x_initiator_transceive_bytes(pnd, abtAttrib, sizeof(abtAttrib), ((void*)0), 0, timeout)) < 0)
        return res;
    }

    found = 1;
    res = 1;
    break;
  } while (pnd->bInfiniteSelect);

  return found ? res : 0;
}
# 1646 "pn53x.c"
static int
pn53x_select_barcode_target(struct nfc_device *pnd,
                            const nfc_modulation nm,
                            uint8_t *abtTargetsData, size_t *szTargetsData,
                            nfc_target *nttmp,
                            int timeout)
{
  int res = 0;
  (void)timeout;

  if (((struct pn53x_data *)(pnd->chip_data))->type == RCS360)
  {

    pnd->last_error = -8;
    return pnd->last_error;
  }


  if ((!((struct pn53x_data *)(pnd->chip_data))->progressive_field) && (res = nfc_device_set_property_bool(pnd, NP_ACTIVATE_FIELD, 0)) < 0)
    return res;


  if ((res = nfc_device_set_property_bool(pnd, NP_HANDLE_CRC, 0)) < 0)
    return res;
  if ((res = nfc_device_set_property_bool(pnd, NP_HANDLE_PARITY, 0)) < 0)
    return res;

  _Bool found = 0;
  do
  {
    uint8_t abtRx[264];
    uint8_t abtRxPar[264];


    if ((res = nfc_initiator_transceive_bits(pnd, ((void*)0), 0, ((void*)0), abtRx, sizeof(abtRx), abtRxPar)) < 0)
    {
      if ((res == -20) || (res == -90))
      {
        continue;
      }
      else
      {
        nfc_device_set_property_bool(pnd, NP_HANDLE_CRC, 1);
        nfc_device_set_property_bool(pnd, NP_HANDLE_PARITY, 1);
        return res;
      }
    }


    size_t szBytes = res / 8;
    size_t off = 0;


    if (nfc_secure_memset(abtTargetsData, 0x00, *szTargetsData) < 0)
      return -90;


    abtTargetsData[off / 8] |= 1 << (7 - (off % 8));
    off++;


    for (size_t szPos = 0; szPos < szBytes; szPos++)
    {
      for (uint8_t i = 0; i < 8; i++)
      {
        abtTargetsData[off / 8] |= ((abtRx[szPos] >> i) & 1) << (7 - (off % 8));
        off++;
      }
      abtTargetsData[off / 8] |= abtRxPar[szPos] << (7 - (off % 8));
      off++;
    }


    uint8_t uRemainder = res % 8;
    for (uint8_t i = 0; i < uRemainder; i++)
    {
      abtTargetsData[off / 8] |= ((abtRx[szBytes] >> i) & 1) << (7 - (off % 8));
      off++;
    }

    if (off % 128 != 0)
    {
      continue;
    }

    *szTargetsData = off / 8;


    uint8_t pbtCrc[2];
    iso14443a_crc(abtTargetsData, *szTargetsData - 2, pbtCrc);
    if ((pbtCrc[1] != abtTargetsData[*szTargetsData - 2]) ||
        (pbtCrc[0] != abtTargetsData[*szTargetsData - 1]))
    {
      continue;
    }

    nttmp->nm = nm;
    if ((res = pn53x_decode_target_data(abtTargetsData, *szTargetsData, ((struct pn53x_data *)(pnd->chip_data))->type, nm.nmt, &(nttmp->nti))) < 0)
      return res;

    found = 1;
    res = 1;
    break;
  } while (pnd->bInfiniteSelect);

  return found ? res : 0;
}

int pn53x_initiator_select_passive_target_ext(struct nfc_device *pnd,
                                              const nfc_modulation nm,
                                              const uint8_t *pbtInitData, const size_t szInitData,
                                              nfc_target *pnt,
                                              int timeout)
{
  uint8_t abtTargetsData[264];
  size_t szTargetsData = sizeof(abtTargetsData);
  int res = 0;
  nfc_target nttmp;


  if (nfc_secure_memset(&nttmp, 0x00, sizeof(nfc_target)) < 0)
    return -90;


  if (nm.nmt == NMT_ISO14443BI || nm.nmt == NMT_ISO14443B2SR ||
      nm.nmt == NMT_ISO14443B2CT || nm.nmt == NMT_ISO14443BICLASS)
  {
    res = pn53x_select_iso14443b_target(pnd, nm, pbtInitData, szInitData,
                                        abtTargetsData, &szTargetsData, &nttmp, timeout);
  }
  else if (nm.nmt == NMT_BARCODE)
  {
    res = pn53x_select_barcode_target(pnd, nm, abtTargetsData, &szTargetsData, &nttmp, timeout);
  }
  else
  {

    const pn53x_modulation pm = pn53x_nm_to_pm(nm);
    if ((PM_UNDEFINED == pm) || (NBR_UNDEFINED == nm.nbr))
    {
      pnd->last_error = -2;
      return pnd->last_error;
    }

    if ((res = pn53x_InListPassiveTarget(pnd, pm, 1, pbtInitData, szInitData, abtTargetsData, &szTargetsData, timeout)) <= 0)
      return res;

    if (szTargetsData <= 1)
      return 0;

    nttmp.nm = nm;
    if ((res = pn53x_decode_target_data(abtTargetsData + 1, szTargetsData - 1, ((struct pn53x_data *)(pnd->chip_data))->type, nm.nmt, &(nttmp.nti))) < 0)
      return res;


    if ((nm.nmt == NMT_ISO14443A) && (nm.nbr != NBR_106))
    {
      uint8_t pncmd_inpsl[4] = {0x4E, 0x01};
      pncmd_inpsl[2] = nm.nbr - 1;
      pncmd_inpsl[3] = nm.nbr - 1;
      if ((res = pn53x_transceive(pnd, pncmd_inpsl, sizeof(pncmd_inpsl), ((void*)0), 0, 0)) < 0)
        return res;
    }


    if (szTargetsData > 0)
    {
      res = abtTargetsData[0];
    }
  }


  if (res <= 0)
    return res;


  if (pn53x_current_target_new(pnd, &nttmp) == ((void*)0))
  {
    pnd->last_error = -80;
    return pnd->last_error;
  }


  if (pnt)
  {
    if (nfc_safe_memcpy(pnt, sizeof(nfc_target), &nttmp, sizeof(nfc_target)) < 0)
      return -90;
  }

  return res;
}

int pn53x_initiator_select_passive_target(struct nfc_device *pnd,
                                          const nfc_modulation nm,
                                          const uint8_t *pbtInitData, const size_t szInitData,
                                          nfc_target *pnt)
{
  return pn53x_initiator_select_passive_target_ext(pnd, nm, pbtInitData, szInitData, pnt, 300);
}


static int
pn53x_poll_target_pn532(struct nfc_device *pnd, const nfc_modulation *pnmModulations,
                        size_t szModulations, uint8_t uiPollNr, uint8_t uiPeriod, nfc_target *pnt)
{
  int res;
  size_t szTargetTypes = 0;
  pn53x_target_type apttTargetTypes[32];


  if (nfc_secure_memset(apttTargetTypes, PTT_UNDEFINED, 32 * sizeof(pn53x_target_type)) < 0)
    return -90;


  for (size_t n = 0; n < szModulations; n++)
  {
    const pn53x_target_type ptt = pn53x_nm_to_ptt(pnmModulations[n]);
    if (PTT_UNDEFINED == ptt)
    {
      pnd->last_error = -2;
      return pnd->last_error;
    }
    apttTargetTypes[szTargetTypes] = ptt;
    if ((pnd->bAutoIso14443_4) && (ptt == PTT_MIFARE))
    {

      apttTargetTypes[szTargetTypes] = PTT_ISO14443_4A_106;
      szTargetTypes++;
      apttTargetTypes[szTargetTypes] = PTT_MIFARE;
    }
    szTargetTypes++;
  }

  nfc_target ntTargets[2];

  if (nfc_secure_memset(ntTargets, 0x00, sizeof(nfc_target) * 2) < 0)
    return -90;

  if ((res = pn53x_InAutoPoll(pnd, apttTargetTypes, szTargetTypes, uiPollNr, uiPeriod, ntTargets, 0)) < 0)
    return res;

  switch (res)
  {
  case 0:
    return pnd->last_error = 0;
  case 1:
    *pnt = ntTargets[0];
    if (pn53x_current_target_new(pnd, pnt) == ((void*)0))
    {
      return pnd->last_error = -80;
    }
    return res;
  case 2:
    *pnt = ntTargets[1];
    if (pn53x_current_target_new(pnd, pnt) == ((void*)0))
    {
      return pnd->last_error = -80;
    }
    return res;
  default:
    return -90;
  }
}


static int
pn53x_poll_target_generic(struct nfc_device *pnd, const nfc_modulation *pnmModulations,
                          size_t szModulations, uint8_t uiPollNr, uint8_t uiPeriod, nfc_target *pnt)
{
  _Bool bInfiniteSelect = pnd->bInfiniteSelect;
  int result = 0;
  int res;

  if ((res = pn53x_set_property_bool(pnd, NP_INFINITE_SELECT, 1)) < 0)
    return res;


  do
  {
    for (size_t p = 0; p < uiPollNr; p++)
    {
      for (size_t n = 0; n < szModulations; n++)
      {
        uint8_t *pbtInitiatorData;
        size_t szInitiatorData;
        prepare_initiator_data(pnmModulations[n], &pbtInitiatorData, &szInitiatorData);
        const int timeout_ms = uiPeriod * 150;

        if ((res = pn53x_initiator_select_passive_target_ext(pnd, pnmModulations[n], pbtInitiatorData, szInitiatorData, pnt, timeout_ms)) < 0)
        {
          if (pnd->last_error != -6)
          {
            result = pnd->last_error;
            goto end;
          }
        }
        else
        {
          result = res;
          goto end;
        }
      }
    }
  } while (uiPollNr == 0xff);


end:
  if (!bInfiniteSelect)
  {
    if ((res = pn53x_set_property_bool(pnd, NP_INFINITE_SELECT, 0)) < 0)
      return res;
  }
  return result;
}

int pn53x_initiator_poll_target(struct nfc_device *pnd,
                                const nfc_modulation *pnmModulations, const size_t szModulations,
                                const uint8_t uiPollNr, const uint8_t uiPeriod,
                                nfc_target *pnt)
{

  if (((struct pn53x_data *)(pnd->chip_data))->type == PN532)
  {
    return pn53x_poll_target_pn532(pnd, pnmModulations, szModulations, uiPollNr, uiPeriod, pnt);
  }
  else
  {
    return pn53x_poll_target_generic(pnd, pnmModulations, szModulations, uiPollNr, uiPeriod, pnt);
  }
}

int pn53x_initiator_select_dep_target(struct nfc_device *pnd,
                                      const nfc_dep_mode ndm, const nfc_baud_rate nbr,
                                      const nfc_dep_info *pndiInitiator,
                                      nfc_target *pnt,
                                      const int timeout)
{
  const uint8_t abtPassiveInitiatorData[] = {0x00, 0xff, 0xff, 0x00, 0x0f};
  const uint8_t *pbtPassiveInitiatorData = ((void*)0);

  switch (nbr)
  {
  case NBR_212:
  case NBR_424:

    pbtPassiveInitiatorData = abtPassiveInitiatorData;
    break;

  case NBR_106:

    break;
  case NBR_847:
  case NBR_UNDEFINED:
    return -2;
  }

  pn53x_current_target_free(pnd);
  int res;
  if (pndiInitiator)
  {
    res = pn53x_InJumpForDEP(pnd, ndm, nbr, pbtPassiveInitiatorData, pndiInitiator->abtNFCID3, pndiInitiator->abtGB, pndiInitiator->szGB, pnt, timeout);
  }
  else
  {
    res = pn53x_InJumpForDEP(pnd, ndm, nbr, pbtPassiveInitiatorData, ((void*)0), ((void*)0), 0, pnt, timeout);
  }
  if (res > 0)
  {
    if (pn53x_current_target_new(pnd, pnt) == ((void*)0))
    {
      return -80;
    }
  }
  return res;
}

int pn53x_initiator_transceive_bits(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits,
                                    const uint8_t *pbtTxPar, uint8_t *pbtRx, uint8_t *pbtRxPar)
{
  int res = 0;
  size_t szFrameBits = 0;
  size_t szFrameBytes = 0;
  size_t szRxBits = 0;
  uint8_t ui8rcc;
  uint8_t ui8Bits = 0;
  uint8_t abtCmd[264] = {0x42};


  if ((!pnd->bPar) && (szTxBits > 0))
  {

    if ((res = pn53x_wrap_frame(pbtTx, szTxBits, pbtTxPar, abtCmd + 1)) < 0)
      return res;
    szFrameBits = res;
  }
  else
  {
    szFrameBits = szTxBits;
  }


  ui8Bits = szFrameBits % 8;


  szFrameBytes = (szFrameBits / 8) + ((ui8Bits == 0) ? 0 : 1);


  if (pnd->bPar)
  {

    if (nfc_safe_memcpy(abtCmd + 1, sizeof(abtCmd) - 1, pbtTx, szFrameBytes) < 0)
      return -90;
  }


  if ((res = pn53x_set_tx_bits(pnd, ui8Bits)) < 0)
    return res;



  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);
  if ((res = pn53x_transceive(pnd, abtCmd, szFrameBytes + 1, abtRx, szRx, -1)) < 0)
    return res;
  szRx = (size_t)res;

  if ((res = pn53x_read_register(pnd, 0x633C, &ui8rcc)) < 0)
    return res;
  ui8Bits = ui8rcc & 0x07;


  szFrameBits = ((szRx - 1 - ((ui8Bits == 0) ? 0 : 1)) * 8) + ui8Bits;

  if (pbtRx != ((void*)0))
  {


    if (!pnd->bPar)
    {

      if ((res = pn53x_unwrap_frame(abtRx + 1, szFrameBits, pbtRx, pbtRxPar)) < 0)
        return res;
      szRxBits = res;
    }
    else
    {

      szRxBits = szFrameBits;

      if (nfc_safe_memcpy(pbtRx, szRx, abtRx + 1, szRx - 1) < 0)
        return -90;
    }
  }

  return szRxBits;
}

int pn53x_initiator_transceive_bytes(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx,
                                     const size_t szRx, int timeout)
{
  size_t szExtraTxLen;
  uint8_t abtCmd[264];
  int res = 0;


  if (!pnd->bPar)
  {
    pnd->last_error = -2;
    return pnd->last_error;
  }


  if (pnd->bEasyFraming)
  {
    abtCmd[0] = 0x40;
    abtCmd[1] = 1;

    if (nfc_safe_memcpy(abtCmd + 2, sizeof(abtCmd) - 2, pbtTx, szTx) < 0)
      return -90;
    szExtraTxLen = 2;
  }
  else
  {
    abtCmd[0] = 0x42;

    if (nfc_safe_memcpy(abtCmd + 1, sizeof(abtCmd) - 1, pbtTx, szTx) < 0)
      return -90;
    szExtraTxLen = 1;
  }


  if ((res = pn53x_set_tx_bits(pnd, 0)) < 0)
  {
    pnd->last_error = res;
    return pnd->last_error;
  }



  uint8_t abtRx[264];
  if ((res = pn53x_transceive(pnd, abtCmd, szTx + szExtraTxLen, abtRx, sizeof(abtRx), timeout)) < 0)
  {
    pnd->last_error = res;
    return pnd->last_error;
  }
  const size_t szRxLen = (size_t)res - 1;
  if (pbtRx != ((void*)0))
  {
    if (szRxLen > szRx)
    {
      log_put(3, "libnfc.chip.pn53x", 1, "Buffer size is too short: %" "l" "u" " available(s), %" "l" "u" " needed", szRx, szRxLen);
      return -5;
    }

    if (nfc_safe_memcpy(pbtRx, szRx, abtRx + 1, szRxLen) < 0)
      return -90;
  }

  return szRxLen;
}

static void __pn53x_init_timer(struct nfc_device *pnd, const uint32_t max_cycles)
{






  if (max_cycles > 0xFFFF)
  {
    ((struct pn53x_data *)(pnd->chip_data))->timer_prescaler = ((max_cycles / 0xFFFF) - 1) / 2;
  }
  else
  {
    ((struct pn53x_data *)(pnd->chip_data))->timer_prescaler = 0;
  }
  uint16_t reloadval = 0xFFFF;

  pn53x_write_register(pnd, 0x631A, 0xFF, 0x80 | ((((struct pn53x_data *)(pnd->chip_data))->timer_prescaler >> 8) & 0x0F));
  pn53x_write_register(pnd, 0x631B, 0xFF, (((struct pn53x_data *)(pnd->chip_data))->timer_prescaler & 0xFF));
  pn53x_write_register(pnd, 0x631C, 0xFF, (reloadval >> 8) & 0xFF);
  pn53x_write_register(pnd, 0x631D, 0xFF, reloadval & 0xFF);
}

static uint32_t __pn53x_get_timer(struct nfc_device *pnd, const uint8_t last_cmd_byte)
{
  uint8_t counter_hi, counter_lo;
  uint16_t counter;
  uint32_t u32cycles;
  size_t off = 0;
  if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
  {

    off = 1;
  }

  uint8_t abtReadRegisterCmd[264]; size_t __abtReadRegisterCmd_n = 0;
  do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x06; } while (0);
  do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x631E >> 8; } while (0);
  do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x631E & 0xff; } while (0);
  do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x631F >> 8; } while (0);
  do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x631F & 0xff; } while (0);
  uint8_t abtRes[264];
  size_t szRes = sizeof(abtRes);

  if (pn53x_transceive(pnd, abtReadRegisterCmd, (__abtReadRegisterCmd_n), abtRes, szRes, -1) < 0)
  {
    return 0;
  }
  counter_hi = abtRes[off];
  counter_lo = abtRes[off + 1];
  counter = counter_hi;
  counter = (counter << 8) + counter_lo;
  if (counter == 0)
  {

    u32cycles = 0xFFFFFFFF;
  }
  else
  {
    uint8_t parity;
    uint16_t u16cycles;
    u16cycles = 0xFFFF - counter;
    u32cycles = u16cycles;
    u32cycles *= (((struct pn53x_data *)(pnd->chip_data))->timer_prescaler * 2 + 1);
    u32cycles++;


    if (((struct pn53x_data *)(pnd->chip_data))->type == PN531)
    {
      u32cycles -= (2 * 128);
    }
    else
    {
      u32cycles -= (5 * 128);
    }

    parity = (last_cmd_byte >> 7) ^ ((last_cmd_byte >> 6) & 1) ^
             ((last_cmd_byte >> 5) & 1) ^ ((last_cmd_byte >> 4) & 1) ^
             ((last_cmd_byte >> 3) & 1) ^ ((last_cmd_byte >> 2) & 1) ^
             ((last_cmd_byte >> 1) & 1) ^ (last_cmd_byte & 1);
    parity = parity ? 0 : 1;

    if (parity)
    {

      u32cycles += 64;
    }

    u32cycles += ((struct pn53x_data *)(pnd->chip_data))->timer_correction;
  }
  return u32cycles;
}

int pn53x_initiator_transceive_bits_timed(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits,
                                          const uint8_t *pbtTxPar, uint8_t *pbtRx, uint8_t *pbtRxPar, uint32_t *cycles)
{

  (void)pbtTxPar;
  (void)pbtRxPar;
  uint16_t i;
  uint8_t sz = 0;
  int res = 0;
  size_t szRxBits = 0;


  if (!pnd->bPar)
  {
    pnd->last_error = -8;
    return pnd->last_error;
  }

  if (pnd->bEasyFraming)
  {
    pnd->last_error = -8;
    return pnd->last_error;
  }


  if (pnd->bCrc)
  {
    pnd->last_error = -8;
    return pnd->last_error;
  }

  __pn53x_init_timer(pnd, *cycles);





  uint8_t abtWriteRegisterCmd[264]; size_t __abtWriteRegisterCmd_n = 0;
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x08; } while (0);

  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6331 >> 8; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6331 & 0xff; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x0F & 0xC; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633A >> 8; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633A & 0xff; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x80; } while (0);
  for (i = 0; i < ((szTxBits / 8) + 1); i++)
  {
    do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6339 >> 8; } while (0);
    do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6339 & 0xff; } while (0);
    do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = pbtTx[i]; } while (0);
  }

  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633D >> 8; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633D & 0xff; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x80 | ((szTxBits % 8) & 0x07); } while (0);

  if ((res = pn53x_transceive(pnd, abtWriteRegisterCmd, (__abtWriteRegisterCmd_n), ((void*)0), 0, -1)) < 0)
  {
    return res;
  }






  for (i = 0; i < (3 * (((struct pn53x_data *)(pnd->chip_data))->timer_prescaler * 2 + 1)); i++)
  {
    pn53x_read_register(pnd, 0x633A, &sz);
    if (sz > 0)
      break;
  }
  size_t off = 0;
  if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
  {

    off = 1;
  }
  while (1)
  {
    uint8_t abtReadRegisterCmd[264]; size_t __abtReadRegisterCmd_n = 0;
    do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x06; } while (0);
    for (i = 0; i < sz; i++)
    {
      do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x6339 >> 8; } while (0);
      do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x6339 & 0xff; } while (0);
    }
    do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x633A >> 8; } while (0);
    do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x633A & 0xff; } while (0);
    uint8_t abtRes[264];
    size_t szRes = sizeof(abtRes);

    if ((res = pn53x_transceive(pnd, abtReadRegisterCmd, (__abtReadRegisterCmd_n), abtRes, szRes, -1)) < 0)
    {
      return res;
    }
    for (i = 0; i < sz; i++)
    {
      pbtRx[i + szRxBits] = abtRes[i + off];
    }
    szRxBits += (size_t)(sz & 0x7F);
    sz = abtRes[sz + off];
    if (sz == 0)
      break;
  }
  szRxBits *= 8;


  *cycles = __pn53x_get_timer(pnd, pbtTx[szTxBits / 8]);

  return szRxBits;
}


static int
pn53x_timed_send_buffer(struct nfc_device *pnd, const uint8_t *pbtTx, size_t szTx)
{
  uint16_t i;
  int res;

  uint8_t abtWriteRegisterCmd[264]; size_t __abtWriteRegisterCmd_n = 0;
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x08; } while (0);


  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6331 >> 8; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6331 & 0xff; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x0F & 0xC; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633A >> 8; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633A & 0xff; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x80; } while (0);


  for (i = 0; i < szTx; i++)
  {
    do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6339 >> 8; } while (0);
    do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x6339 & 0xff; } while (0);
    do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = pbtTx[i]; } while (0);
  }


  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633D >> 8; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x633D & 0xff; } while (0);
  do { abtWriteRegisterCmd[__abtWriteRegisterCmd_n++] = 0x80; } while (0);

  if ((res = pn53x_transceive(pnd, abtWriteRegisterCmd, (__abtWriteRegisterCmd_n), ((void*)0), 0, -1)) < 0)
  {
    return res;
  }

  return 0;
}


static int
pn53x_timed_receive_data(struct nfc_device *pnd, uint8_t *pbtRx, size_t szRx, size_t *pszRxLen)
{
  uint16_t i;
  uint8_t sz = 0;
  int res;
  size_t szRxLen = 0;


  for (i = 0; i < (3 * (((struct pn53x_data *)(pnd->chip_data))->timer_prescaler * 2 + 1)); i++)
  {
    pn53x_read_register(pnd, 0x633A, &sz);
    if (sz > 0)
      break;
  }


  size_t off = (((struct pn53x_data *)(pnd->chip_data))->type == PN533) ? 1 : 0;


  while (1)
  {
    uint8_t abtReadRegisterCmd[264]; size_t __abtReadRegisterCmd_n = 0;
    do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x06; } while (0);

    for (i = 0; i < sz; i++)
    {
      do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x6339 >> 8; } while (0);
      do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x6339 & 0xff; } while (0);
    }
    do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x633A >> 8; } while (0);
    do { abtReadRegisterCmd[__abtReadRegisterCmd_n++] = 0x633A & 0xff; } while (0);

    uint8_t abtRes[264];
    size_t szRes = sizeof(abtRes);

    if ((res = pn53x_transceive(pnd, abtReadRegisterCmd, (__abtReadRegisterCmd_n), abtRes, szRes, -1)) < 0)
    {
      return res;
    }

    if (pbtRx != ((void*)0))
    {
      if ((szRxLen + sz) > szRx)
      {
        log_put(3, "libnfc.chip.pn53x", 1,
                "Buffer size is too short: %" "l" "u" " available(s), %" "l" "u" " needed", szRx, szRxLen + sz);
        return -5;
      }
      for (i = 0; i < sz; i++)
      {
        pbtRx[i + szRxLen] = abtRes[i + off];
      }
    }

    szRxLen += (size_t)(sz & 0x7F);
    sz = abtRes[sz + off];
    if (sz == 0)
      break;
  }

  *pszRxLen = szRxLen;
  return 0;
}


static int
pn53x_timed_compute_cycles(struct nfc_device *pnd, const uint8_t *pbtTx, size_t szTx,
                           uint8_t txmode, uint32_t *cycles)
{
  uint8_t *pbtTxRaw = (uint8_t *)calloc(szTx + 2, 1);
  if (!pbtTxRaw)
    return -80;

  if (nfc_safe_memcpy(pbtTxRaw, szTx + 2, pbtTx, szTx) < 0)
  {
    free(pbtTxRaw);
    return -90;
  }


  if ((txmode & 0x03) == 0x00)
    iso14443a_crc_append(pbtTxRaw, szTx);
  else if ((txmode & 0x03) == 0x03)
    iso14443b_crc_append(pbtTxRaw, szTx);
  else
    log_put(3, "libnfc.chip.pn53x", 1,
            "Unsupported framing type %02X, cannot adjust CRC cycles", txmode & 0x03);

  *cycles = __pn53x_get_timer(pnd, pbtTxRaw[szTx + 1]);
  free(pbtTxRaw);

  return 0;
}

int pn53x_initiator_transceive_bytes_timed(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, uint32_t *cycles)
{
  uint16_t i;
  uint8_t sz = 0;
  int res;
  size_t szRxLen = 0;


  if (!pnd->bPar)
  {
    pnd->last_error = -2;
    return pnd->last_error;
  }
  if (pnd->bEasyFraming)
  {
    pnd->last_error = -8;
    return pnd->last_error;
  }


  uint8_t txmode = 0;
  if (pnd->bCrc)
  {

    if ((res = pn53x_read_register(pnd, 0x6302, &txmode)) < 0)
    {
      return res;
    }
  }


  __pn53x_init_timer(pnd, *cycles);


  if ((res = pn53x_timed_send_buffer(pnd, pbtTx, szTx)) < 0)
  {
    return res;
  }


  if ((res = pn53x_timed_receive_data(pnd, pbtRx, szRx, &szRxLen)) < 0)
  {
    return res;
  }


  if (pnd->bCrc)
  {
    if ((res = pn53x_timed_compute_cycles(pnd, pbtTx, szTx, txmode, cycles)) < 0)
    {
      return res;
    }
  }
  else
  {
    *cycles = __pn53x_get_timer(pnd, pbtTx[szTx - 1]);
  }

  return szRxLen;
}

int pn53x_initiator_deselect_target(struct nfc_device *pnd)
{
  pn53x_current_target_free(pnd);
  return pn53x_InDeselect(pnd, 0);
}

static int pn53x_Diagnose06(struct nfc_device *pnd)
{

  const uint8_t abtCmd[] = {0x00, 0x06};
  uint8_t abtRx[1];
  int ret = 0;
  int failures = 0;





  while (failures < 2)
  {
    if ((ret = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), abtRx, sizeof(abtRx), 1000)) != 1)
    {

      if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
      {
        return -10;
      }
      else
      {

        failures++;
      }
    }
    else
    {
      return 0;
    }
  }
  return ret;
}

static int pn53x_ISO14443A_4_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping -4A");
  if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
  {
    ret = pn53x_Diagnose06(pnd);
    if ((ret == -6) || (ret == -10))
    {


      const uint8_t abtCmd[] = {0x52, 0x00};
      pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 2000);
      ret = -10;
    }
  }
  else if (((struct pn53x_data *)(pnd->chip_data))->type == PN532)
  {

    if ((ret = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 0)) < 0)
      return ret;
    uint8_t abtCmd[1] = {0xb2};
    int failures = 0;
    while (failures < 2)
    {
      if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 300)) < 1)
      {
        if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
        {

          ret = -10;
          break;
        }
        else
        {

          failures++;
        }
      }
      else
      {
        ret = 0;
        break;
      }
    }
    int ret2;
    if ((ret2 = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 1)) < 0)
      ret = ret2;
  }
  else
  {
    ret = -3;
  }
  return ret;
}

static int pn53x_ISO14443A_Jewel_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping Jewel");
  uint8_t abtCmd[1] = {0x78};
  int failures = 0;
  while (failures < 2)
  {
    if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1)) < 1)
    {
      if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
      {

        return -10;
      }
      else
      {

        failures++;
      }
    }
    else
    {
      return 0;
    }
  }
  return ret;
}

static int pn53x_ISO14443A_Barcode_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping Barcode");


  if ((!((struct pn53x_data *)(pnd->chip_data))->progressive_field) && (ret = nfc_device_set_property_bool(pnd, NP_ACTIVATE_FIELD, 0)) < 0)
  {
    return ret;
  }
  if ((ret = nfc_device_set_property_bool(pnd, NP_HANDLE_CRC, 0)) < 0)
    return ret;
  if ((ret = nfc_device_set_property_bool(pnd, NP_HANDLE_PARITY, 0)) < 0)
    return ret;

  int failures = 0;
  while (failures < 3)
  {
    if ((!((struct pn53x_data *)(pnd->chip_data))->progressive_field) && (ret = nfc_device_set_property_bool(pnd, NP_ACTIVATE_FIELD, 0)) < 0)
    {
      return ret;
    }
    uint8_t abtRx[264];
    uint8_t abtRxPar[264];
    if (nfc_initiator_transceive_bits(pnd, ((void*)0), 0, ((void*)0), abtRx, sizeof(abtRx), abtRxPar) < 1)
    {
      failures++;
    }
    else
    {
      nfc_device_set_property_bool(pnd, NP_HANDLE_CRC, 1);
      nfc_device_set_property_bool(pnd, NP_HANDLE_PARITY, 1);
      return 0;
    }
  }
  nfc_device_set_property_bool(pnd, NP_HANDLE_CRC, 1);
  nfc_device_set_property_bool(pnd, NP_HANDLE_PARITY, 1);
  return -10;
}

static int pn53x_ISO14443A_MFUL_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping MFUL");

  if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
  {
    ret = pn53x_Diagnose06(pnd);
  }
  else
  {
    uint8_t abtCmd[2] = {0x30, 0x00};
    int failures = 0;
    while (failures < 2)
    {
      if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1)) < 1)
      {
        if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
        {

          return -10;
        }
        else
        {

          failures++;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return ret;
}

static int pn53x_ISO14443A_MFC_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping MFC");
  if ((((struct pn53x_data *)(pnd->chip_data))->type == PN533) && (((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nai.btSak != 0x09))
  {

    ret = pn53x_Diagnose06(pnd);
  }
  else
  {

    _Bool bInfiniteSelect = pnd->bInfiniteSelect;
    uint8_t pbtInitiatorData[12];
    size_t szInitiatorData = 0;
    iso14443_cascade_uid(((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nai.abtUid, ((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nai.szUidLen, pbtInitiatorData, &szInitiatorData);
    if ((ret = pn53x_set_property_bool(pnd, NP_INFINITE_SELECT, 0)) < 0)
      return ret;
    if ((ret = pn53x_initiator_select_passive_target_ext(pnd, ((struct pn53x_data *)(pnd->chip_data))->current_target->nm, pbtInitiatorData, szInitiatorData, ((void*)0), 300)) == 1)
    {
      ret = 0;
    }
    else if ((ret == 0) || (ret == -6))
    {
      ret = -10;
    }
    if (bInfiniteSelect)
    {
      int ret2;
      if ((ret2 = pn53x_set_property_bool(pnd, NP_INFINITE_SELECT, 1)) < 0)
        return ret2;
    }
  }
  return ret;
}

static int pn53x_DEP_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping DEP");
  if ((((struct pn53x_data *)(pnd->chip_data))->type == PN531) || (((struct pn53x_data *)(pnd->chip_data))->type == PN532) || (((struct pn53x_data *)(pnd->chip_data))->type == PN533))
    ret = pn53x_Diagnose06(pnd);
  else
    ret = -3;
  return ret;
}

static int pn53x_Felica_is_present(struct nfc_device *pnd)
{
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping Felica");



  uint8_t abtCmd[10] = {0x0A, 0x04};

  if (nfc_safe_memcpy(abtCmd + 2, sizeof(abtCmd) - 2, ((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nfi.abtId, 8) < 0)
    return -90;
  int failures = 0;

  while (failures < 3)
  {
    if (nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 300) == 11)
    {
      return 0;
    }
    else
    {
      failures++;
    }
  }
  return -10;
}

static int pn53x_ISO14443B_4_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping -4B");
  if (((struct pn53x_data *)(pnd->chip_data))->type == PN533)
  {

    ret = pn53x_Diagnose06(pnd);
  }
  else
  {

    if ((ret = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 0)) < 0)
      return ret;

    uint8_t abtCmd[2] = {0xba, 0x01};
    int failures = 0;
    while (failures < 2)
    {
      if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 300)) < 1)
      {
        if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
        {

          ret = -10;
          break;
        }
        else
        {

          failures++;
        }
      }
      else
      {
        ret = 0;
        break;
      }
    }
    int ret2;
    if ((ret2 = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 1)) < 0)
      ret = ret2;
  }
  return ret;
}

static int pn53x_ISO14443B_I_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping B'");

  if ((ret = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 0)) < 0)
    return ret;
  uint8_t abtCmd[6] = {0x01, 0x0f};

  if (nfc_safe_memcpy(abtCmd + 2, sizeof(abtCmd) - 2, ((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nii.abtDIV, 4) < 0)
    return -90;
  int failures = 0;
  while (failures < 2)
  {
    if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 300)) < 1)
    {
      if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
      {

        ret = -10;
        break;
      }
      else
      {

        failures++;
      }
    }
    else
    {
      ret = 0;
      break;
    }
  }
  int ret2;
  if ((ret2 = pn53x_set_property_bool(pnd, NP_EASY_FRAMING, 1)) < 0)
    ret = ret2;
  return ret;
}

static int pn53x_ISO14443B_SR_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping B2 ST SRx");

  uint8_t abtCmd[1] = {0x0b};
  int failures = 0;
  while (failures < 2)
  {
    if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 300)) < 1)
    {
      if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
      {

        ret = -10;
        break;
      }
      else
      {

        failures++;
      }
    }
    else
    {
      ret = 0;
      break;
    }
  }
  return ret;
}

static int pn53x_ISO14443B_ICLASS_is_present(struct nfc_device *pnd)
{
  int timeout = 300;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping B iClass");
  pn53x_initiator_init_iclass_modulation(pnd);



  uint8_t abtReqt[] = {0x0a};
  uint8_t abtAnticol[11];
  if (pn53x_initiator_transceive_bytes(pnd, abtReqt, sizeof(abtReqt), ((void*)0), 0, timeout) < 0)
  {
    log_put(3, "libnfc.chip.pn53x", 3, "got expected timeout on iClass activate all");
  }

  abtReqt[0] = 0x0c;
  abtAnticol[0] = 0x81;
  if (pn53x_initiator_transceive_bytes(pnd, abtReqt, sizeof(abtReqt), &abtAnticol[1], sizeof(abtAnticol) - 1, timeout) < 0)
  {
    log_put(3, "libnfc.chip.pn53x", 3, "timeout on iClass anticol");
    return -10;
    ;
  }
  return 0;
}

static int pn53x_ISO14443B_CT_is_present(struct nfc_device *pnd)
{
  int ret;
  log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): Ping B2 ASK CTx");

  uint8_t abtCmd[3] = {0x9f};

  if (nfc_safe_memcpy(abtCmd + 1, sizeof(abtCmd) - 1, ((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nci.abtUID, 2) < 0)
    return -90;
  int failures = 0;
  while (failures < 2)
  {
    if ((ret = nfc_initiator_transceive_bytes(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, 300)) < 1)
    {
      if ((ret == -20) && (((struct pn53x_data *)(pnd->chip_data))->last_status_byte == 0x01))
      {

        ret = -10;
        break;
      }
      else
      {

        failures++;
      }
    }
    else
    {
      ret = 0;
      break;
    }
  }
  return ret;
}


static int
pn53x_check_iso14443a_presence(struct nfc_device *pnd)
{
  const nfc_target *target = ((struct pn53x_data *)(pnd->chip_data))->current_target;

  if (target->nti.nai.btSak & 0x20)
  {

    return pn53x_ISO14443A_4_is_present(pnd);
  }
  else if ((target->nti.nai.abtAtqa[0] == 0x00) &&
           (target->nti.nai.abtAtqa[1] == 0x44) &&
           (target->nti.nai.btSak == 0x00))
  {

    return pn53x_ISO14443A_MFUL_is_present(pnd);
  }
  else if (target->nti.nai.btSak & 0x08)
  {

    return pn53x_ISO14443A_MFC_is_present(pnd);
  }
  else
  {
    log_put(3, "libnfc.chip.pn53x", 3, "%s",
            "target_is_present(): card type A not supported");
    return -3;
  }
}


typedef int (*is_present_func_t)(struct nfc_device *);

typedef struct
{
  nfc_modulation_type nmt;
  is_present_func_t func;
} is_present_map_t;

static const is_present_map_t is_present_table[] = {
    {NMT_ISO14443A, pn53x_check_iso14443a_presence},
    {NMT_DEP, pn53x_DEP_is_present},
    {NMT_FELICA, pn53x_Felica_is_present},
    {NMT_JEWEL, pn53x_ISO14443A_Jewel_is_present},
    {NMT_BARCODE, pn53x_ISO14443A_Barcode_is_present},
    {NMT_ISO14443B, pn53x_ISO14443B_4_is_present},
    {NMT_ISO14443BI, pn53x_ISO14443B_I_is_present},
    {NMT_ISO14443B2SR, pn53x_ISO14443B_SR_is_present},
    {NMT_ISO14443B2CT, pn53x_ISO14443B_CT_is_present},
    {NMT_ISO14443BICLASS, pn53x_ISO14443B_ICLASS_is_present},
};

int pn53x_initiator_target_is_present(struct nfc_device *pnd, const nfc_target *pnt)
{

  if (((struct pn53x_data *)(pnd->chip_data))->current_target == ((void*)0))
  {
    log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): no saved target");
    return pnd->last_error = -2;
  }


  if ((pnt != ((void*)0)) && (!pn53x_current_target_is(pnd, pnt)))
  {
    log_put(3, "libnfc.chip.pn53x", 3, "%s", "target_is_present(): another target");
    return pnd->last_error = -10;
  }


  nfc_modulation_type nmt = ((struct pn53x_data *)(pnd->chip_data))->current_target->nm.nmt;
  int ret = -3;

  for (size_t i = 0; i < sizeof(is_present_table) / sizeof(is_present_table[0]); i++)
  {
    if (is_present_table[i].nmt == nmt)
    {
      ret = is_present_table[i].func(pnd);
      break;
    }
  }

  if (ret == -10)
    pn53x_current_target_free(pnd);

  return pnd->last_error = ret;
}
# 3126 "pn53x.c"
static int
pn53x_setup_target_mode(struct nfc_device *pnd, const nfc_target *pnt)
{
  pn53x_target_mode ptm = PTM_NORMAL;

  switch (pnt->nm.nmt)
  {
  case NMT_ISO14443A:
    ptm = PTM_PASSIVE_ONLY;


    if ((pnt->nti.nai.abtUid[0] != 0x08) || (pnt->nti.nai.szUidLen != 4))
    {
      pnd->last_error = -2;
      return pnd->last_error;
    }

    pn53x_set_parameters(pnd, 0x04, 0);


    if (((struct pn53x_data *)(pnd->chip_data))->type == PN532)
    {
      if ((pnt->nti.nai.btSak & 0x20) && (pnd->bAutoIso14443_4))
      {

        ptm |= PTM_ISO14443_4_PICC_ONLY;
        pn53x_set_parameters(pnd, 0x20, 1);
      }
      else
      {
        pn53x_set_parameters(pnd, 0x20, 0);
      }
    }
    break;

  case NMT_FELICA:
    ptm = PTM_PASSIVE_ONLY;
    break;

  case NMT_DEP:
    pn53x_set_parameters(pnd, 0x04, 1);
    ptm = PTM_DEP_ONLY;


    if (pnt->nti.ndi.ndm == NDM_PASSIVE)
    {
      ptm |= PTM_PASSIVE_ONLY;
    }
    break;

  case NMT_ISO14443B:
  case NMT_ISO14443BI:
  case NMT_ISO14443B2SR:
  case NMT_ISO14443B2CT:
  case NMT_ISO14443BICLASS:
  case NMT_JEWEL:
  case NMT_BARCODE:
    pnd->last_error = -3;
    return pnd->last_error;
  }

  return ptm;
}
# 3200 "pn53x.c"
static void
pn53x_decode_activation_mode(uint8_t btActivatedMode, nfc_modulation *nm, nfc_dep_mode *ndm)
{

  nm->nmt = NMT_DEP;
  nm->nbr = NBR_UNDEFINED;
  *ndm = NDM_UNDEFINED;


  switch (btActivatedMode & 0x70)
  {
  case 0x00:
    nm->nbr = NBR_106;
    break;
  case 0x10:
    nm->nbr = NBR_212;
    break;
  case 0x20:
    nm->nbr = NBR_424;
    break;
  }


  if (btActivatedMode & 0x04)
  {

    nm->nmt = NMT_DEP;
    if ((btActivatedMode & 0x03) == 0x01)
    {
      *ndm = NDM_ACTIVE;
    }
    else
    {
      *ndm = NDM_PASSIVE;
    }
  }
  else
  {

    if ((btActivatedMode & 0x03) == 0x00)
    {

      nm->nmt = NMT_ISO14443A;
    }
    else if ((btActivatedMode & 0x03) == 0x02)
    {

      nm->nmt = NMT_FELICA;
    }
  }
}
# 3259 "pn53x.c"
static _Bool
is_activation_compatible(const nfc_target *pnt, const nfc_modulation *nm, nfc_dep_mode ndm)
{

  if (pnt->nm.nmt != nm->nmt)
  {
    return 0;
  }


  if ((pnt->nm.nbr != NBR_UNDEFINED) && (pnt->nm.nbr != nm->nbr))
  {
    return 0;
  }


  if (pnt->nm.nmt == NMT_DEP)
  {
    if ((pnt->nti.ndi.ndm != NDM_UNDEFINED) && (pnt->nti.ndi.ndm != ndm))
    {
      return 0;
    }
  }

  return 1;
}

int pn53x_target_init(struct nfc_device *pnd, nfc_target *pnt, uint8_t *pbtRx, const size_t szRxLen, int timeout)
{
  pn53x_reset_settings(pnd);

  ((struct pn53x_data *)(pnd->chip_data))->operating_mode = TARGET;


  int ptm_result = pn53x_setup_target_mode(pnd, pnt);
  if (ptm_result < 0)
  {
    return ptm_result;
  }
  pn53x_target_mode ptm = (pn53x_target_mode)ptm_result;

  int res = 0;


  if ((res = pn53x_write_register(pnd, 0x6305, 0x04, 0x04)) < 0)
    return res;

  uint8_t abtMifareParams[6];
  uint8_t *pbtMifareParams = ((void*)0);
  uint8_t *pbtTkt = ((void*)0);
  size_t szTkt = 0;

  uint8_t abtFeliCaParams[18];
  uint8_t *pbtFeliCaParams = ((void*)0);

  const uint8_t *pbtNFCID3t = ((void*)0);
  const uint8_t *pbtGBt = ((void*)0);
  size_t szGBt = 0;

  switch (pnt->nm.nmt)
  {
  case NMT_ISO14443A:
  {

    abtMifareParams[0] = pnt->nti.nai.abtAtqa[1];
    abtMifareParams[1] = pnt->nti.nai.abtAtqa[0];


    abtMifareParams[2] = pnt->nti.nai.abtUid[1];
    abtMifareParams[3] = pnt->nti.nai.abtUid[2];
    abtMifareParams[4] = pnt->nti.nai.abtUid[3];

    abtMifareParams[5] = pnt->nti.nai.btSak;

    pbtMifareParams = abtMifareParams;


    pbtTkt = iso14443a_locate_historical_bytes(pnt->nti.nai.abtAts, pnt->nti.nai.szAtsLen, &szTkt);
  }
  break;

  case NMT_FELICA:

    if (nfc_safe_memcpy(abtFeliCaParams, sizeof(abtFeliCaParams), pnt->nti.nfi.abtId, 8) < 0)
      return -90;

    if (nfc_safe_memcpy(abtFeliCaParams + 8, sizeof(abtFeliCaParams) - 8, pnt->nti.nfi.abtPad, 8) < 0)
      return -90;

    if (nfc_safe_memcpy(abtFeliCaParams + 16, sizeof(abtFeliCaParams) - 16, pnt->nti.nfi.abtSysCode, 2) < 0)
      return -90;
    pbtFeliCaParams = abtFeliCaParams;
    break;

  case NMT_DEP:

    pbtNFCID3t = pnt->nti.ndi.abtNFCID3;

    szGBt = pnt->nti.ndi.szGB;
    if (szGBt)
      pbtGBt = pnt->nti.ndi.abtGB;



    abtMifareParams[0] = 0x08;
    abtMifareParams[1] = 0x00;


    abtMifareParams[2] = 0x12;
    abtMifareParams[3] = 0x34;
    abtMifareParams[4] = 0x56;

    abtMifareParams[5] = 0x40;

    pbtMifareParams = abtMifareParams;



    abtFeliCaParams[0] = 0x01;
    abtFeliCaParams[1] = 0xfe;
    abtFeliCaParams[2] = 0x12;
    abtFeliCaParams[3] = 0x34;
    abtFeliCaParams[4] = 0x56;
    abtFeliCaParams[5] = 0x78;
    abtFeliCaParams[6] = 0x90;
    abtFeliCaParams[7] = 0x12;

    abtFeliCaParams[8] = 0xc0;
    abtFeliCaParams[9] = 0xc1;
    abtFeliCaParams[10] = 0xc2;
    abtFeliCaParams[11] = 0xc3;
    abtFeliCaParams[12] = 0xc4;
    abtFeliCaParams[13] = 0xc5;
    abtFeliCaParams[14] = 0xc6;
    abtFeliCaParams[15] = 0xc7;

    abtFeliCaParams[16] = 0x0f;
    abtFeliCaParams[17] = 0xab;

    pbtFeliCaParams = abtFeliCaParams;
    break;
  case NMT_ISO14443B:
  case NMT_ISO14443BI:
  case NMT_ISO14443B2SR:
  case NMT_ISO14443B2CT:
  case NMT_ISO14443BICLASS:
  case NMT_JEWEL:
  case NMT_BARCODE:
    pnd->last_error = -3;
    return pnd->last_error;
  }

  _Bool targetActivated = 0;
  size_t szRx;
  while (!targetActivated)
  {
    uint8_t btActivatedMode;

    if ((res = pn53x_TgInitAsTarget(pnd, ptm, pbtMifareParams, pbtTkt, szTkt, pbtFeliCaParams, pbtNFCID3t, pbtGBt, szGBt, pbtRx, szRxLen, &btActivatedMode, timeout)) < 0)
    {
      if (res == -6)
      {
        pn53x_idle(pnd);
      }
      return res;
    }
    szRx = (size_t)res;


    nfc_modulation nm;
    nfc_dep_mode ndm;
    pn53x_decode_activation_mode(btActivatedMode, &nm, &ndm);


    targetActivated = is_activation_compatible(pnt, &nm, ndm);

    if (targetActivated)
    {
      pnt->nm.nbr = nm.nbr;
      if (pnt->nm.nmt == NMT_DEP)
      {
        pnt->nti.ndi.ndm = ndm;
      }
      if (pn53x_current_target_new(pnd, pnt) == ((void*)0))
      {
        pnd->last_error = -80;
        return pnd->last_error;
      }

      if (ptm & PTM_ISO14443_4_PICC_ONLY)
      {


        szRx = 0;
      }
    }
  }

  return szRx;
}

int pn53x_target_receive_bits(struct nfc_device *pnd, uint8_t *pbtRx, const size_t szRxLen, uint8_t *pbtRxPar)
{
  size_t szRxBits = 0;
  uint8_t abtCmd[] = {0x88};

  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);
  int res = 0;


  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), abtRx, szRx, -1)) < 0)
    return res;
  szRx = (size_t)res;

  uint8_t ui8rcc;
  if ((res = pn53x_read_register(pnd, 0x633C, &ui8rcc)) < 0)
    return res;
  uint8_t ui8Bits = ui8rcc & 0x07;


  size_t szFrameBits = ((szRx - 1 - ((ui8Bits == 0) ? 0 : 1)) * 8) + ui8Bits;



  if (!pnd->bPar)
  {

    if ((res = pn53x_unwrap_frame(abtRx + 1, szFrameBits, pbtRx, pbtRxPar)) < 0)
      return res;
    szRxBits = res;
  }
  else
  {

    szRxBits = szFrameBits;

    if ((szRx - 1) > szRxLen)
      return -5;

    if (nfc_safe_memcpy(pbtRx, szRxLen, abtRx + 1, szRx - 1) < 0)
      return -90;
  }

  return szRxBits;
}

int pn53x_target_receive_bytes(struct nfc_device *pnd, uint8_t *pbtRx, const size_t szRxLen, int timeout)
{
  uint8_t abtCmd[1];



  if (pnd->bEasyFraming)
  {
    switch (((struct pn53x_data *)(pnd->chip_data))->current_target->nm.nmt)
    {
    case NMT_DEP:
      abtCmd[0] = 0x86;
      break;
    case NMT_ISO14443A:
      if (((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nai.btSak & 0x20)
      {

        if ((((struct pn53x_data *)(pnd->chip_data))->type == PN532) && (pnd->bAutoIso14443_4))
        {

          abtCmd[0] = 0x86;
          break;
        }
        else
        {


          pnd->last_error = -8;
          return pnd->last_error;
        }
      }
      abtCmd[0] = 0x88;
      break;
    case NMT_JEWEL:
    case NMT_BARCODE:
    case NMT_ISO14443B:
    case NMT_ISO14443BI:
    case NMT_ISO14443B2SR:
    case NMT_ISO14443B2CT:
    case NMT_ISO14443BICLASS:
    case NMT_FELICA:
      abtCmd[0] = 0x88;
      break;
    }
  }
  else
  {
    abtCmd[0] = 0x88;
  }


  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);
  int res = 0;
  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), abtRx, szRx, timeout)) < 0)
    return pnd->last_error;
  szRx = (size_t)res;

  szRx -= 1;

  if (szRx > szRxLen)
    return -5;


  if (nfc_safe_memcpy(pbtRx, szRxLen, abtRx + 1, szRx) < 0)
    return -90;


  return szRx;
}

int pn53x_target_send_bits(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar)
{
  size_t szFrameBits = 0;
  size_t szFrameBytes = 0;
  uint8_t ui8Bits = 0;
  uint8_t abtCmd[264] = {0x90};
  int res = 0;


  if (!pnd->bPar)
  {

    if ((res = pn53x_wrap_frame(pbtTx, szTxBits, pbtTxPar, abtCmd + 1)) < 0)
      return res;
    szFrameBits = res;
  }
  else
  {
    szFrameBits = szTxBits;
  }


  ui8Bits = szFrameBits % 8;


  szFrameBytes = (szFrameBits / 8) + ((ui8Bits == 0) ? 0 : 1);


  if (pnd->bPar)
  {
    if (nfc_safe_memcpy(abtCmd + 1, sizeof(abtCmd) - 1, pbtTx, szFrameBytes) < 0)
      return -90;
  }


  if ((res = pn53x_set_tx_bits(pnd, ui8Bits)) < 0)
    return res;


  if ((res = pn53x_transceive(pnd, abtCmd, szFrameBytes + 1, ((void*)0), 0, -1)) < 0)
    return res;


  return szTxBits;
}

int pn53x_target_send_bytes(struct nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, int timeout)
{
  uint8_t abtCmd[264];
  int res = 0;


  if (!pnd->bPar)
    return -90;



  if (pnd->bEasyFraming)
  {
    switch (((struct pn53x_data *)(pnd->chip_data))->current_target->nm.nmt)
    {
    case NMT_DEP:
      abtCmd[0] = 0x8E;
      break;
    case NMT_ISO14443A:
      if (((struct pn53x_data *)(pnd->chip_data))->current_target->nti.nai.btSak & 0x20)
      {

        if ((((struct pn53x_data *)(pnd->chip_data))->type == PN532) && (pnd->bAutoIso14443_4))
        {

          abtCmd[0] = 0x8E;
          break;
        }
        else
        {


          pnd->last_error = -8;
          return pnd->last_error;
        }
      }
      abtCmd[0] = 0x90;
      break;
    case NMT_JEWEL:
    case NMT_BARCODE:
    case NMT_ISO14443B:
    case NMT_ISO14443BI:
    case NMT_ISO14443B2SR:
    case NMT_ISO14443B2CT:
    case NMT_ISO14443BICLASS:
    case NMT_FELICA:
      abtCmd[0] = 0x90;
      break;
    }
  }
  else
  {
    abtCmd[0] = 0x90;
  }


  if (nfc_safe_memcpy(abtCmd + 1, sizeof(abtCmd) - 1, pbtTx, szTx) < 0)
    return -90;


  if ((res = pn53x_transceive(pnd, abtCmd, szTx + 1, ((void*)0), 0, timeout)) < 0)
    return res;


  return szTx;
}

static struct sErrorMessage
{
  int iErrorCode;
  const char *pcErrorMsg;
} sErrorMessages[] = {

    {0x00, "Success"},
    {0x01, "Timeout"},
    {0x02, "CRC Error"},
    {0x03, "Parity Error"},
    {0x04, "Erroneous Bit Count"},
    {0x05, "Framing Error"},
    {0x06, "Bit-collision"},
    {0x07, "Communication Buffer Too Small"},
    {0x09, "Buffer Overflow"},
    {0x0b, "RF Protocol Error"},
    {0x0d, "Chip Overheating"},
    {0x0e, "Internal Buffer overflow."},
    {0x10, "Invalid Parameter"},
    {0x26, "Operation Not Allowed"},
    {0x27, "Command Not Acceptable"},
    {0x2d, "Over Current"},

    {0x0a, "RF Timeout"},
    {0x12, "Unknown DEP Command"},
    {0x25, "Invalid DEP State"},
    {0x2e, "NAD Missing in DEP Frame"},

    {0x14, "Mifare Authentication Error"},

    {0x13, "Invalid Received Frame"},
    {0x18, "NFC Secure not supported"},
    {0x23, "Wrong UID Check Byte (BCC)"},
    {0x29, "Target Released"},
    {0x2a, "Card ID Mismatch"},
    {0x2b, "Card Discarded"},
    {0x2c, "NFCID3 Mismatch"},
};

const char *
pn53x_strerror(const struct nfc_device *pnd)
{
  const char *pcRes = "Unknown error";
  size_t i;

  for (i = 0; i < (sizeof(sErrorMessages) / sizeof(struct sErrorMessage)); i++)
  {
    if (sErrorMessages[i].iErrorCode == ((struct pn53x_data *)(pnd->chip_data))->last_status_byte)
    {
      pcRes = sErrorMessages[i].pcErrorMsg;
      break;
    }
  }

  return pcRes;
}

int pn53x_RFConfiguration__RF_field(struct nfc_device *pnd, _Bool bEnable)
{
  uint8_t abtCmd[] = {0x32, 0x01, (bEnable) ? 0x01 : 0x00};
  return pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1);
}

int pn53x_RFConfiguration__Various_timings(struct nfc_device *pnd, const uint8_t fATR_RES_Timeout, const uint8_t fRetryTimeout)
{
  uint8_t abtCmd[] = {
      0x32,
      0x02,
      0x00,
      fATR_RES_Timeout,
      fRetryTimeout
  };
  return pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1);
}

int pn53x_RFConfiguration__MaxRtyCOM(struct nfc_device *pnd, const uint8_t MaxRtyCOM)
{
  uint8_t abtCmd[] = {
      0x32,
      0x04,
      MaxRtyCOM
  };
  return pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1);
}

int pn53x_RFConfiguration__MaxRetries(struct nfc_device *pnd, const uint8_t MxRtyATR, const uint8_t MxRtyPSL, const uint8_t MxRtyPassiveActivation)
{

  uint8_t abtCmd[] = {
      0x32,
      0x05,
      MxRtyATR,
      MxRtyPSL,
      MxRtyPassiveActivation
  };
  return pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1);
}

int pn53x_SetParameters(struct nfc_device *pnd, const uint8_t ui8Value)
{
  uint8_t abtCmd[] = {0x12, ui8Value};
  int res = 0;

  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1)) < 0)
  {
    return res;
  }

  ((struct pn53x_data *)(pnd->chip_data))->ui8Parameters = ui8Value;
  return 0;
}

int pn532_SAMConfiguration(struct nfc_device *pnd, const pn532_sam_mode sam_mode, int timeout)
{
  uint8_t abtCmd[] = {0x14, sam_mode, 0x00, 0x00};
  size_t szCmd = sizeof(abtCmd);

  if (((struct pn53x_data *)(pnd->chip_data))->type != PN532)
  {

    pnd->last_error = -3;
    return pnd->last_error;
  }

  switch (sam_mode)
  {
  case PSM_NORMAL:
  case PSM_WIRED_CARD:
    szCmd = 2;
    break;
  case PSM_VIRTUAL_CARD:
  case PSM_DUAL_CARD:

    szCmd = 3;
    break;
  default:
    pnd->last_error = -2;
    return pnd->last_error;
  }
  ((struct pn53x_data *)(pnd->chip_data))->sam_mode = sam_mode;
  return (pn53x_transceive(pnd, abtCmd, szCmd, ((void*)0), 0, timeout));
}

int pn53x_PowerDown(struct nfc_device *pnd)
{
  uint8_t abtCmd[] = {0x16, 0xf0};
  int res;
  if ((res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1)) < 0)
    return res;
  ((struct pn53x_data *)(pnd->chip_data))->power_mode = LOWVBAT;
  return res;
}







static int
validate_modulation_support(struct nfc_device *pnd, pn53x_modulation pmModulation)
{
  switch (pmModulation)
  {
  case PM_ISO14443A_106:
  case PM_FELICA_212:
  case PM_FELICA_424:
    return 0;

  case PM_ISO14443B_106:
    if (!(pnd->btSupportByte & 0x02))
    {
      return -3;
    }
    return 0;

  case PM_JEWEL_106:
  case PM_BARCODE_106:
    if (((struct pn53x_data *)(pnd->chip_data))->type == PN531)
    {
      return -3;
    }
    return 0;

  case PM_ISO14443B_212:
  case PM_ISO14443B_424:
  case PM_ISO14443B_847:
    if ((((struct pn53x_data *)(pnd->chip_data))->type != PN533) || (!(pnd->btSupportByte & 0x02)))
    {
      return -3;
    }
    return 0;

  case PM_UNDEFINED:
    return -2;

  default:
    return -2;
  }
}
# 3905 "pn53x.c"
int pn53x_InListPassiveTarget(struct nfc_device *pnd,
                              const pn53x_modulation pmInitModulation, const uint8_t szMaxTargets,
                              const uint8_t *pbtInitiatorData, const size_t szInitiatorData,
                              uint8_t *pbtTargetsData, size_t *pszTargetsData,
                              int timeout)
{

  int validation_result = validate_modulation_support(pnd, pmInitModulation);
  if (validation_result != 0)
  {
    pnd->last_error = validation_result;
    return validation_result;
  }


  uint8_t abtCmd[15] = {0x4A};
  abtCmd[1] = szMaxTargets;
  abtCmd[2] = pmInitModulation;



  if (pbtInitiatorData)
  {

    if (szInitiatorData > 12)
    {
      pnd->last_error = -2;
      return -2;
    }

    if (nfc_safe_memcpy(abtCmd + 3, sizeof(abtCmd) - 3, pbtInitiatorData, szInitiatorData) < 0)
      return -2;
  }


  int res = 0;
  if ((res = pn53x_transceive(pnd, abtCmd, 3 + szInitiatorData, pbtTargetsData, *pszTargetsData, timeout)) < 0)
  {
    return res;
  }
  *pszTargetsData = (size_t)res;
  return pbtTargetsData[0];
}

int pn53x_InDeselect(struct nfc_device *pnd, const uint8_t ui8Target)
{
  if (((struct pn53x_data *)(pnd->chip_data))->type == RCS360)
  {

    uint8_t abtStatus[264];
    size_t szStatus = sizeof(abtStatus);
    uint8_t abtCmdGetStatus[] = {0x04};
    int res = 0;
    if ((res = pn53x_transceive(pnd, abtCmdGetStatus, sizeof(abtCmdGetStatus), abtStatus, szStatus, -1)) < 0)
    {
      return res;
    }
    szStatus = (size_t)res;
    if ((szStatus < 3) || (abtStatus[2] == 0))
    {
      return 0;
    }

    uint8_t abtCmdRcs360[] = {0x44, 0x01, 0x01};
    return (pn53x_transceive(pnd, abtCmdRcs360, sizeof(abtCmdRcs360), ((void*)0), 0, -1));
  }
  uint8_t abtCmd[] = {0x44, ui8Target};
  return (pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1));
}

int pn53x_InRelease(struct nfc_device *pnd, const uint8_t ui8Target)
{
  int res = 0;
  if (((struct pn53x_data *)(pnd->chip_data))->type == RCS360)
  {

    uint8_t abtStatus[264];
    size_t szStatus = sizeof(abtStatus);
    uint8_t abtCmdGetStatus[] = {0x04};
    if ((res = pn53x_transceive(pnd, abtCmdGetStatus, sizeof(abtCmdGetStatus), abtStatus, szStatus, -1)) < 0)
    {
      return res;
    }
    szStatus = (size_t)res;
    if ((szStatus < 3) || (abtStatus[2] == 0))
    {
      return 0;
    }

    uint8_t abtCmdRcs360[] = {0x52, 0x01, 0x01};
    res = pn53x_transceive(pnd, abtCmdRcs360, sizeof(abtCmdRcs360), ((void*)0), 0, -1);
    return (res >= 0) ? 0 : res;
  }
  uint8_t abtCmd[] = {0x52, ui8Target};
  res = pn53x_transceive(pnd, abtCmd, sizeof(abtCmd), ((void*)0), 0, -1);
  return (res >= 0) ? 0 : res;
}

int pn53x_InAutoPoll(struct nfc_device *pnd,
                     const pn53x_target_type *ppttTargetTypes, const size_t szTargetTypes,
                     const uint8_t btPollNr, const uint8_t btPeriod, nfc_target *pntTargets, const int timeout)
{
  size_t szTargetFound = 0;
  if (((struct pn53x_data *)(pnd->chip_data))->type != PN532)
  {

    pnd->last_error = -3;
    return pnd->last_error;
  }


  size_t szTxInAutoPoll = 3 + szTargetTypes;
  uint8_t abtCmd[3 + 15] = {0x60, btPollNr, btPeriod};
  for (size_t n = 0; n < szTargetTypes; n++)
  {
    abtCmd[3 + n] = ppttTargetTypes[n];
  }

  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);
  int res = pn53x_transceive(pnd, abtCmd, szTxInAutoPoll, abtRx, szRx, timeout);
  szRx = (size_t)res;
  if (res < 0)
  {
    return res;
  }
  else if (szRx > 0)
  {
    szTargetFound = abtRx[0];
    if (szTargetFound > 0)
    {
      uint8_t ln;
      uint8_t *pbt = abtRx + 1;


      pn53x_target_type ptt = *(pbt++);
      pntTargets[0].nm = pn53x_ptt_to_nm(ptt);

      ln = *(pbt++);
      if ((res = pn53x_decode_target_data(pbt, ln, ((struct pn53x_data *)(pnd->chip_data))->type, pntTargets[0].nm.nmt, &(pntTargets[0].nti))) < 0)
      {
        return res;
      }
      pbt += ln;

      if (abtRx[0] > 1)
      {


        ptt = *(pbt++);
        pntTargets[1].nm = pn53x_ptt_to_nm(ptt);

        ln = *(pbt++);
        pn53x_decode_target_data(pbt, ln, ((struct pn53x_data *)(pnd->chip_data))->type, pntTargets[1].nm.nmt, &(pntTargets[1].nti));
      }
    }
  }
  return szTargetFound;
}
# 4080 "pn53x.c"
static int
pn53x_build_injumpfordep_command(uint8_t *abtCmd,
                                 const nfc_dep_mode ndm,
                                 const nfc_baud_rate nbr,
                                 const uint8_t *pbtPassiveInitiatorData,
                                 const uint8_t *pbtNFCID3i,
                                 const uint8_t *pbtGBi,
                                 const size_t szGBi)
{
  abtCmd[0] = 0x56;
  abtCmd[1] = (ndm == NDM_ACTIVE) ? 0x01 : 0x00;
  abtCmd[3] = 0x00;

  size_t offset = 4;


  switch (nbr)
  {
  case NBR_106:
    abtCmd[2] = 0x00;
    if (pbtPassiveInitiatorData && (ndm == NDM_PASSIVE))
    {
      abtCmd[3] |= 0x01;
      if (nfc_safe_memcpy(abtCmd + offset, 67 - offset, pbtPassiveInitiatorData, 4) < 0)
        return -90;
      offset += 4;
    }
    break;
  case NBR_212:
    abtCmd[2] = 0x01;
    if (pbtPassiveInitiatorData && (ndm == NDM_PASSIVE))
    {
      abtCmd[3] |= 0x01;
      if (nfc_safe_memcpy(abtCmd + offset, 67 - offset, pbtPassiveInitiatorData, 5) < 0)
        return -90;
      offset += 5;
    }
    break;
  case NBR_424:
    abtCmd[2] = 0x02;
    if (pbtPassiveInitiatorData && (ndm == NDM_PASSIVE))
    {
      abtCmd[3] |= 0x01;
      if (nfc_safe_memcpy(abtCmd + offset, 67 - offset, pbtPassiveInitiatorData, 5) < 0)
        return -90;
      offset += 5;
    }
    break;
  case NBR_847:
  case NBR_UNDEFINED:
    return -2;
  }


  if (pbtNFCID3i)
  {
    abtCmd[3] |= 0x02;
    if (nfc_safe_memcpy(abtCmd + offset, 67 - offset, pbtNFCID3i, 10) < 0)
      return -90;
    offset += 10;
  }


  if (szGBi && pbtGBi)
  {
    abtCmd[3] |= 0x04;
    if (nfc_safe_memcpy(abtCmd + offset, 67 - offset, pbtGBi, szGBi) < 0)
      return -90;
    offset += szGBi;
  }

  return (int)offset;
}
# 4167 "pn53x.c"
static int
pn53x_parse_injumpfordep_response(nfc_target *pnt,
                                  const uint8_t *abtRx,
                                  size_t szRx,
                                  const nfc_dep_mode ndm,
                                  const nfc_baud_rate nbr)
{
  if (!pnt)
  {
    return 0;
  }

  pnt->nm.nmt = NMT_DEP;
  pnt->nm.nbr = nbr;
  pnt->nti.ndi.ndm = ndm;


  if (nfc_safe_memcpy(pnt->nti.ndi.abtNFCID3, sizeof(pnt->nti.ndi.abtNFCID3), abtRx + 2, 10) < 0)
    return -90;


  pnt->nti.ndi.btDID = abtRx[12];
  pnt->nti.ndi.btBS = abtRx[13];
  pnt->nti.ndi.btBR = abtRx[14];
  pnt->nti.ndi.btTO = abtRx[15];
  pnt->nti.ndi.btPP = abtRx[16];


  if (szRx > 17)
  {
    pnt->nti.ndi.szGB = szRx - 17;
    if (nfc_safe_memcpy(pnt->nti.ndi.abtGB, sizeof(pnt->nti.ndi.abtGB), abtRx + 17, pnt->nti.ndi.szGB) < 0)
      return -90;
  }
  else
  {
    pnt->nti.ndi.szGB = 0;
  }

  return 0;
}
# 4219 "pn53x.c"
int pn53x_InJumpForDEP(struct nfc_device *pnd,
                       const nfc_dep_mode ndm,
                       const nfc_baud_rate nbr,
                       const uint8_t *pbtPassiveInitiatorData,
                       const uint8_t *pbtNFCID3i,
                       const uint8_t *pbtGBi, const size_t szGBi,
                       nfc_target *pnt,
                       const int timeout)
{
  uint8_t abtCmd[67];
  int res;


  res = pn53x_build_injumpfordep_command(abtCmd, ndm, nbr,
                                         pbtPassiveInitiatorData,
                                         pbtNFCID3i, pbtGBi, szGBi);
  if (res < 0)
  {
    if (res == -2)
    {
      pnd->last_error = -2;
      return pnd->last_error;
    }
    return res;
  }

  size_t cmd_len = (size_t)res;


  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);

  if ((res = pn53x_transceive(pnd, abtCmd, cmd_len, abtRx, szRx, timeout)) < 0)
    return res;
  szRx = (size_t)res;


  if (abtRx[1] >= 1)
  {

    if ((res = pn53x_parse_injumpfordep_response(pnt, abtRx, szRx, ndm, nbr)) < 0)
      return res;
  }

  return abtRx[1];
}

int pn53x_TgInitAsTarget(struct nfc_device *pnd, pn53x_target_mode ptm,
                         const uint8_t *pbtMifareParams,
                         const uint8_t *pbtTkt, size_t szTkt,
                         const uint8_t *pbtFeliCaParams,
                         const uint8_t *pbtNFCID3t, const uint8_t *pbtGBt, const size_t szGBt,
                         uint8_t *pbtRx, const size_t szRxLen, uint8_t *pbtModeByte, int timeout)
{
  uint8_t abtCmd[39 + 47 + 48] = {0x8C};
  size_t szOptionalBytes = 0;
  int res = 0;


  if (nfc_secure_memset(abtCmd + 1, 0x00, sizeof(abtCmd) - 1) < 0)
    return -90;


  abtCmd[1] = ptm;


  if (pbtMifareParams)
  {
    if (nfc_safe_memcpy(abtCmd + 2, sizeof(abtCmd) - 2, pbtMifareParams, 6) < 0)
      return -90;
  }

  if (pbtFeliCaParams)
  {
    if (nfc_safe_memcpy(abtCmd + 8, sizeof(abtCmd) - 8, pbtFeliCaParams, 18) < 0)
      return -90;
  }

  if (pbtNFCID3t)
  {
    if (nfc_safe_memcpy(abtCmd + 26, sizeof(abtCmd) - 26, pbtNFCID3t, 10) < 0)
      return -90;
  }

  if ((((struct pn53x_data *)(pnd->chip_data))->type == PN531) || (((struct pn53x_data *)(pnd->chip_data))->type == RCS360))
  {
    if (szGBt)
    {
      if (nfc_safe_memcpy(abtCmd + 36, sizeof(abtCmd) - 36, pbtGBt, szGBt) < 0)
        return -90;
      szOptionalBytes = szGBt;
    }
  }
  else
  {
    abtCmd[36] = (uint8_t)(szGBt);
    if (szGBt)
    {

      if (nfc_safe_memcpy(abtCmd + 37, sizeof(abtCmd) - 37, pbtGBt, szGBt) < 0)
        return -90;
    }
    szOptionalBytes = szGBt + 1;
  }

  if ((((struct pn53x_data *)(pnd->chip_data))->type != PN531) && (((struct pn53x_data *)(pnd->chip_data))->type != RCS360))
  {

    abtCmd[36 + szOptionalBytes] = (uint8_t)(szTkt);
    if (szTkt)
    {

      if (nfc_safe_memcpy(abtCmd + 37 + szOptionalBytes, sizeof(abtCmd) - 37 - szOptionalBytes, pbtTkt, szTkt) < 0)
        return -90;
    }
    szOptionalBytes += szTkt + 1;
  }


  uint8_t abtRx[264];
  size_t szRx = sizeof(abtRx);
  if ((res = pn53x_transceive(pnd, abtCmd, 36 + szOptionalBytes, abtRx, szRx, timeout)) < 0)
    return res;
  szRx = (size_t)res;



  if (pbtModeByte)
  {
    *pbtModeByte = abtRx[0];
  }


  szRx -= 1;

  if ((szRx - 1) > szRxLen)
    return -5;

  if (nfc_safe_memcpy(pbtRx, szRxLen, abtRx + 1, szRx) < 0)
    return -90;

  return szRx;
}

int pn53x_check_ack_frame(struct nfc_device *pnd, const uint8_t *pbtRxFrame, const size_t szRxFrameLen)
{
  if (szRxFrameLen >= sizeof(pn53x_ack_frame))
  {
    if (0 == memcmp(pbtRxFrame, pn53x_ack_frame, sizeof(pn53x_ack_frame)))
    {
      log_put(3, "libnfc.chip.pn53x", 3, "%s", "PN53x ACKed");
      return 0;
    }
  }
  pnd->last_error = -1;
  log_put(3, "libnfc.chip.pn53x", 1, "%s", "Unexpected PN53x reply!");
  return pnd->last_error;
}

int pn53x_check_error_frame(struct nfc_device *pnd, const uint8_t *pbtRxFrame, const size_t szRxFrameLen)
{
  if (szRxFrameLen >= sizeof(pn53x_error_frame))
  {
    if (0 == memcmp(pbtRxFrame, pn53x_error_frame, sizeof(pn53x_error_frame)))
    {
      log_put(3, "libnfc.chip.pn53x", 3, "%s", "PN53x sent an error frame");
      pnd->last_error = -1;
      return pnd->last_error;
    }
  }
  return 0;
}







int pn53x_build_frame(uint8_t *pbtFrame, size_t *pszFrame, const uint8_t *pbtData, const size_t szData)
{

  if (!pbtFrame || !pszFrame || !pbtData)
  {
    log_put(3, "libnfc.chip.pn53x", 1, "Invalid NULL pointer in pn53x_build_frame");
    return -2;
  }

  if (szData <= 254)
  {

    pbtFrame[3] = szData + 1;

    pbtFrame[4] = 256 - (szData + 1);

    pbtFrame[5] = 0xD4;


    if (nfc_safe_memcpy(pbtFrame + 6, 264 + 11 - 6, pbtData, szData) < 0)
      return -1;


    uint8_t btDCS = (256 - 0xD4);
    for (size_t szPos = 0; szPos < szData; szPos++)
    {
      btDCS -= pbtData[szPos];
    }
    pbtFrame[6 + szData] = btDCS;


    pbtFrame[szData + 7] = 0x00;

    (*pszFrame) = szData + 8;
  }
  else if (szData <= 264)
  {

    pbtFrame[3] = 0xff;
    pbtFrame[4] = 0xff;

    pbtFrame[5] = (szData + 1) >> 8;

    pbtFrame[6] = (szData + 1) & 0xff;

    pbtFrame[7] = 256 - ((pbtFrame[5] + pbtFrame[6]) & 0xff);

    pbtFrame[8] = 0xD4;


    if (nfc_safe_memcpy(pbtFrame + 9, 264 + 11 - 9, pbtData, szData) < 0)
      return -1;


    uint8_t btDCS = (256 - 0xD4);
    for (size_t szPos = 0; szPos < szData; szPos++)
    {
      btDCS -= pbtData[szPos];
    }
    pbtFrame[9 + szData] = btDCS;


    pbtFrame[szData + 10] = 0x00;

    (*pszFrame) = szData + 11;
  }
  else
  {
    log_put(3, "libnfc.chip.pn53x", 1, "We can't send more than %d bytes in a raw (requested: %" "l" "d" ")", 264, szData);
    return -90;
  }
  return 0;
}


typedef struct
{
  nfc_modulation_type nmt;
  nfc_baud_rate nbr;
  pn53x_modulation pm;
} nm_to_pm_map_t;

static const nm_to_pm_map_t nm_to_pm_table[] = {

    {NMT_ISO14443A, NBR_UNDEFINED, PM_ISO14443A_106},


    {NMT_ISO14443B, NBR_106, PM_ISO14443B_106},
    {NMT_ISO14443B, NBR_212, PM_ISO14443B_212},
    {NMT_ISO14443B, NBR_424, PM_ISO14443B_424},
    {NMT_ISO14443B, NBR_847, PM_ISO14443B_847},
    {NMT_ISO14443BICLASS, NBR_106, PM_ISO14443B_106},
    {NMT_ISO14443BICLASS, NBR_212, PM_ISO14443B_212},
    {NMT_ISO14443BICLASS, NBR_424, PM_ISO14443B_424},
    {NMT_ISO14443BICLASS, NBR_847, PM_ISO14443B_847},


    {NMT_JEWEL, NBR_UNDEFINED, PM_JEWEL_106},
    {NMT_BARCODE, NBR_UNDEFINED, PM_BARCODE_106},


    {NMT_FELICA, NBR_212, PM_FELICA_212},
    {NMT_FELICA, NBR_424, PM_FELICA_424},
};

pn53x_modulation
pn53x_nm_to_pm(const nfc_modulation nm)
{

  for (size_t i = 0; i < sizeof(nm_to_pm_table) / sizeof(nm_to_pm_table[0]); i++)
  {
    if (nm_to_pm_table[i].nmt == nm.nmt)
    {
      if (nm_to_pm_table[i].nbr == NBR_UNDEFINED || nm_to_pm_table[i].nbr == nm.nbr)
      {
        return nm_to_pm_table[i].pm;
      }
    }
  }
  return PM_UNDEFINED;
}


typedef struct
{
  pn53x_target_type ptt;
  nfc_modulation nm;
} ptt_to_nm_map_t;

static const ptt_to_nm_map_t ptt_to_nm_table[] = {

    {PTT_MIFARE, {.nmt = NMT_ISO14443A, .nbr = NBR_106}},
    {PTT_ISO14443_4A_106, {.nmt = NMT_ISO14443A, .nbr = NBR_106}},


    {PTT_ISO14443_4B_106, {.nmt = NMT_ISO14443B, .nbr = NBR_106}},
    {PTT_ISO14443_4B_TCL_106, {.nmt = NMT_ISO14443B, .nbr = NBR_106}},


    {PTT_JEWEL_106, {.nmt = NMT_JEWEL, .nbr = NBR_106}},


    {PTT_FELICA_212, {.nmt = NMT_FELICA, .nbr = NBR_212}},
    {PTT_FELICA_424, {.nmt = NMT_FELICA, .nbr = NBR_424}},


    {PTT_DEP_PASSIVE_106, {.nmt = NMT_DEP, .nbr = NBR_106}},
    {PTT_DEP_ACTIVE_106, {.nmt = NMT_DEP, .nbr = NBR_106}},
    {PTT_DEP_PASSIVE_212, {.nmt = NMT_DEP, .nbr = NBR_212}},
    {PTT_DEP_ACTIVE_212, {.nmt = NMT_DEP, .nbr = NBR_212}},
    {PTT_DEP_PASSIVE_424, {.nmt = NMT_DEP, .nbr = NBR_424}},
    {PTT_DEP_ACTIVE_424, {.nmt = NMT_DEP, .nbr = NBR_424}},
};

nfc_modulation
pn53x_ptt_to_nm(const pn53x_target_type ptt)
{
  for (size_t i = 0; i < sizeof(ptt_to_nm_table) / sizeof(ptt_to_nm_table[0]); i++)
  {
    if (ptt_to_nm_table[i].ptt == ptt)
    {
      return ptt_to_nm_table[i].nm;
    }
  }

  return (const nfc_modulation){.nmt = NMT_ISO14443A, .nbr = NBR_106};
}


typedef struct
{
  nfc_modulation_type nmt;
  nfc_baud_rate nbr;
  pn53x_target_type ptt;
} nm_to_ptt_map_t;

static const nm_to_ptt_map_t nm_to_ptt_table[] = {

    {NMT_ISO14443A, NBR_UNDEFINED, PTT_MIFARE},


    {NMT_ISO14443B, NBR_106, PTT_ISO14443_4B_106},
    {NMT_ISO14443BICLASS, NBR_106, PTT_ISO14443_4B_106},


    {NMT_JEWEL, NBR_UNDEFINED, PTT_JEWEL_106},


    {NMT_FELICA, NBR_212, PTT_FELICA_212},
    {NMT_FELICA, NBR_424, PTT_FELICA_424},
};

pn53x_target_type
pn53x_nm_to_ptt(const nfc_modulation nm)
{

  for (size_t i = 0; i < sizeof(nm_to_ptt_table) / sizeof(nm_to_ptt_table[0]); i++)
  {
    if (nm_to_ptt_table[i].nmt == nm.nmt)
    {
      if (nm_to_ptt_table[i].nbr == NBR_UNDEFINED || nm_to_ptt_table[i].nbr == nm.nbr)
      {
        return nm_to_ptt_table[i].ptt;
      }
    }
  }
  return PTT_UNDEFINED;
}

int pn53x_get_supported_modulation(nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type **const supported_mt)
{
  switch (mode)
  {
  case N_TARGET:
    *supported_mt = ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_target;
    break;
  case N_INITIATOR:
    *supported_mt = ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator;
    break;
  default:
    return -2;
  }
  return 0;
}

int pn53x_get_supported_baud_rate(nfc_device *pnd, const nfc_mode mode, const nfc_modulation_type nmt, const nfc_baud_rate **const supported_br)
{
  switch (nmt)
  {
  case NMT_FELICA:
    *supported_br = (nfc_baud_rate *)pn53x_felica_supported_baud_rates;
    break;
  case NMT_ISO14443A:
  {
    if ((((struct pn53x_data *)(pnd->chip_data))->type != PN533) || (mode == N_TARGET))
    {
      *supported_br = (nfc_baud_rate *)pn532_iso14443a_supported_baud_rates;
    }
    else
    {
      *supported_br = (nfc_baud_rate *)pn533_iso14443a_supported_baud_rates;
    }
  }
  break;
  case NMT_ISO14443B:
  {
    if ((((struct pn53x_data *)(pnd->chip_data))->type != PN533))
    {
      *supported_br = (nfc_baud_rate *)pn532_iso14443b_supported_baud_rates;
    }
    else
    {
      *supported_br = (nfc_baud_rate *)pn533_iso14443b_supported_baud_rates;
    }
  }
  break;
  case NMT_ISO14443BI:
  case NMT_ISO14443B2SR:
  case NMT_ISO14443B2CT:
  case NMT_ISO14443BICLASS:
    *supported_br = (nfc_baud_rate *)pn532_iso14443b_supported_baud_rates;
    break;
  case NMT_JEWEL:
    *supported_br = (nfc_baud_rate *)pn53x_jewel_supported_baud_rates;
    break;
  case NMT_BARCODE:
    *supported_br = (nfc_baud_rate *)pn53x_barcode_supported_baud_rates;
    break;
  case NMT_DEP:
    *supported_br = (nfc_baud_rate *)pn53x_dep_supported_baud_rates;
    break;
  default:
    return -2;
  }
  return 0;
}
# 4688 "pn53x.c"
static int
pn53x_safe_append(char **buf, size_t *buflen, char **pbuf, const char *fmt, ...)
{
  va_list args;
  __builtin_va_start(args, fmt);
  int res = vsnprintf(*buf, *buflen, fmt, args);
  __builtin_va_end(args);

  if (res < 0)
  {
    free(*pbuf);
    *pbuf = ((void*)0);
    return -80;
  }

  if (*buflen <= (size_t)res)
  {
    free(*pbuf);
    *pbuf = ((void*)0);
    return -5;
  }

  *buf += res;
  *buflen -= res;
  return 0;
}
# 4727 "pn53x.c"
static int
pn53x_format_mode_info(nfc_device *pnd, nfc_mode mode,
                       char **buf, size_t *buflen, char **pbuf)
{
  const nfc_modulation_type *nmt;
  int res;

  if ((res = nfc_device_get_supported_modulation(pnd, mode, &nmt)) < 0)
  {
    free(*pbuf);
    *pbuf = ((void*)0);
    return res;
  }

  for (int i = 0; nmt[i]; i++)
  {

    if ((res = pn53x_safe_append(buf, buflen, pbuf, "%s%s (",
                                 (i == 0) ? "" : ", ",
                                 str_nfc_modulation_type(nmt[i]))) < 0)
    {
      return res;
    }


    const nfc_baud_rate *nbr;
    if (mode == N_INITIATOR)
    {
      if ((res = nfc_device_get_supported_baud_rate(pnd, nmt[i], &nbr)) < 0)
      {
        free(*pbuf);
        *pbuf = ((void*)0);
        return res;
      }
    }
    else
    {
      if ((res = nfc_device_get_supported_baud_rate_target_mode(pnd, nmt[i], &nbr)) < 0)
      {
        free(*pbuf);
        *pbuf = ((void*)0);
        return res;
      }
    }


    for (int j = 0; nbr[j]; j++)
    {
      if ((res = pn53x_safe_append(buf, buflen, pbuf, "%s%s",
                                   (j == 0) ? "" : ", ",
                                   str_nfc_baud_rate(nbr[j]))) < 0)
      {
        return res;
      }
    }


    if ((res = pn53x_safe_append(buf, buflen, pbuf, ")")) < 0)
    {
      return res;
    }
  }

  return 0;
}

int pn53x_get_information_about(nfc_device *pnd, char **pbuf)
{
  size_t buflen = 2048;
  *pbuf = malloc(buflen);
  if (!*pbuf)
  {
    return -80;
  }
  char *buf = *pbuf;
  int res;


  if ((res = pn53x_safe_append(&buf, &buflen, pbuf, "chip: %s\n",
                               ((struct pn53x_data *)(pnd->chip_data))->firmware_text)) < 0)
  {
    return res;
  }


  if ((res = pn53x_safe_append(&buf, &buflen, pbuf, "initator mode modulations: ")) < 0)
  {
    return res;
  }

  if ((res = pn53x_format_mode_info(pnd, N_INITIATOR, &buf, &buflen, pbuf)) < 0)
  {
    return res;
  }


  if ((res = pn53x_safe_append(&buf, &buflen, pbuf, "\n")) < 0)
  {
    return res;
  }


  if ((res = pn53x_safe_append(&buf, &buflen, pbuf, "target mode modulations: ")) < 0)
  {
    return res;
  }

  if ((res = pn53x_format_mode_info(pnd, N_TARGET, &buf, &buflen, pbuf)) < 0)
  {
    return res;
  }


  if ((res = pn53x_safe_append(&buf, &buflen, pbuf, "\n")) < 0)
  {
    return res;
  }

  return 0;
}

void *
pn53x_current_target_new(const struct nfc_device *pnd, const nfc_target *pnt)
{
  if (pnt == ((void*)0))
  {
    return ((void*)0);
  }

  if (((struct pn53x_data *)(pnd->chip_data))->current_target)
  {
    free(((struct pn53x_data *)(pnd->chip_data))->current_target);
  }
  ((struct pn53x_data *)(pnd->chip_data))->current_target = malloc(sizeof(nfc_target));
  if (!((struct pn53x_data *)(pnd->chip_data))->current_target)
  {
    return ((void*)0);
  }

  if (nfc_safe_memcpy(((struct pn53x_data *)(pnd->chip_data))->current_target, sizeof(nfc_target), pnt, sizeof(nfc_target)) < 0)
  {
    free(((struct pn53x_data *)(pnd->chip_data))->current_target);
    ((struct pn53x_data *)(pnd->chip_data))->current_target = ((void*)0);
    return ((void*)0);
  }
  return ((struct pn53x_data *)(pnd->chip_data))->current_target;
}

void pn53x_current_target_free(const struct nfc_device *pnd)
{
  if (((struct pn53x_data *)(pnd->chip_data))->current_target)
  {
    free(((struct pn53x_data *)(pnd->chip_data))->current_target);
    ((struct pn53x_data *)(pnd->chip_data))->current_target = ((void*)0);
  }
}

_Bool pn53x_current_target_is(const struct nfc_device *pnd, const nfc_target *pnt)
{
  if ((((struct pn53x_data *)(pnd->chip_data))->current_target == ((void*)0)) || (pnt == ((void*)0)))
  {
    return 0;
  }

  if (0 != memcmp(pnt, ((struct pn53x_data *)(pnd->chip_data))->current_target, sizeof(nfc_target)))
  {
    return 0;
  }
  return 1;
}

void *
pn53x_data_new(struct nfc_device *pnd, const struct pn53x_io *io)
{
  pnd->chip_data = malloc(sizeof(struct pn53x_data));
  if (!pnd->chip_data)
  {
    return ((void*)0);
  }

  ((struct pn53x_data *)(pnd->chip_data))->io = io;


  ((struct pn53x_data *)(pnd->chip_data))->type = PN53X;



  ((struct pn53x_data *)(pnd->chip_data))->power_mode = NORMAL;


  ((struct pn53x_data *)(pnd->chip_data))->operating_mode = INITIATOR;


  ((struct pn53x_data *)(pnd->chip_data))->last_status_byte = 0x00;


  ((struct pn53x_data *)(pnd->chip_data))->current_target = ((void*)0);


  ((struct pn53x_data *)(pnd->chip_data))->sam_mode = PSM_NORMAL;


  ((struct pn53x_data *)(pnd->chip_data))->wb_trigged = 0;
  if (nfc_secure_memset(((struct pn53x_data *)(pnd->chip_data))->wb_mask, 0x00, ((0x633E - 0x6301) + 1)) < 0)
  {
    free(pnd->chip_data);
    pnd->chip_data = ((void*)0);
    return ((void*)0);
  }


  ((struct pn53x_data *)(pnd->chip_data))->timeout_command = 350;


  ((struct pn53x_data *)(pnd->chip_data))->timeout_atr = 103;


  ((struct pn53x_data *)(pnd->chip_data))->timeout_communication = 52;

  ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator = ((void*)0);

  ((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_target = ((void*)0);


  ((struct pn53x_data *)(pnd->chip_data))->progressive_field = 0;

  return pnd->chip_data;
}

void pn53x_data_free(struct nfc_device *pnd)
{

  pn53x_current_target_free(pnd);


  if (((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator)
  {
    free(((struct pn53x_data *)(pnd->chip_data))->supported_modulation_as_initiator);
  }
  free(pnd->chip_data);
}
